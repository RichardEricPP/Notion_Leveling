<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex; /* Use flexbox for layout */
            flex-direction: column; /* Allow stacking of difficulty screen and canvas */
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #222;
            font-family: 'Georgia', serif;
            position: relative; 
        }
        #difficultyScreen {
            padding: 20px; 
            background-color: #f4e4bc;
            border: 5px solid #4a2f1b;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 20px rgba(0,0,0,0.6);
            display: flex; 
            flex-direction: column; 
            align-items: center; 
        }
        #difficultyScreen h2 {
            color: #4a2f1b;
            margin-bottom: 15px; 
        }
        #difficultyScreen button {
            background-color: #8B4513; 
            color: white;
            border: 2px solid #4a2f1b;
            padding: 8px 15px; 
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 15px; 
            transition: background-color 0.3s;
        }
        #difficultyScreen button:hover {
            background-color: #A0522D; 
        }
        #lastScoreDisplay {
            margin-top: 10px; 
            font-size: 13px; 
            color: #4a2f1b;
        }
        #debugControls {
            margin-top: 10px; 
            padding: 8px; 
            background-color: #333;
            border-radius: 5px;
            color: white;
            font-size: 13px;
        }
        #debugControls label {
            margin-right: 3px;
        }
        #debugControls input {
            width: 35px; 
            margin-right: 8px;
            padding: 3px;
        }
        #debugControls button {
            padding: 5px 10px;
            font-size: 13px;
        }

        #gameCanvas {
            border: 2px solid #4a2f1b; 
            background: #2a1f15; 
            display: none; 
        }
        #minimapCanvas {
            position: absolute;
            top: 20px;
            left: 20px;
            border: 2px solid #4a2f1b;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 100; 
            display: none;
        }
        #inventoryMenu, #skillMenu {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #f4e4bc;
            padding: 20px; 
            border: 4px solid #8B4513;
            font-family: 'Georgia', serif;
            color: #000;
            z-index: 10;
            min-width: 300px; 
            max-height: 80vh; 
            overflow-y: auto; 
            box-shadow: 0 0 15px rgba(0,0,0,0.5); 
        }
        
        #equipmentMenu {
            display: none; /* Hidden by default, shown by button on difficultyScreen */
            position: absolute; 
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #f4e4bc;
            padding: 20px; 
            border: 4px solid #8B4513;
            font-family: 'Georgia', serif;
            color: #000;
            z-index: 10;
            min-width: 350px; /* Increased width for buttons */
            max-height: 80vh; 
            overflow-y: auto; 
            box-shadow: 0 0 15px rgba(0,0,0,0.5); 
        }

        #inventoryMenu h2, #skillMenu h2, #equipmentMenu h2 {
            margin-top: 0;
            text-align: center;
            color: #4a2f1b;
        }
        #inventoryMenu ul, #skillMenu ul {
            list-style-type: none;
            padding: 0;
        }
        #inventoryMenu li, #skillMenu li {
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 4px;
            cursor: default; 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
        }
        .selected { background-color: #ffd700; color: #000; }
        .unlocked { color: #000000; font-weight: normal; } /* Default for unlocked, not equipped */
        .available { color: #000000; }
        .locked { color: #808080; font-style: italic; } 
        .skill-used { color: #909090 !important; text-decoration: line-through;} 

        .inventory-equipped { color: #008000; font-weight: bold; } /* Green for equipped */
        .inventory-unequipped { color: #808080; } /* Gray for unequipped */

        .skill-equipped { color: #008000; font-weight: bold; }

        #inventoryMenu p, #skillMenu p, #equipmentMenu p {
            font-size: 0.9em;
            text-align: center;
            margin-top: 15px;
            color: #4a2f1b;
        }
        #messageBox {
            position: absolute;
            bottom: 20px; /* Position at the bottom */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(244, 228, 188, 0.8); /* Added transparency */
            border: 4px solid #8B4513;
            border-radius: 10px;
            padding: 15px 25px; /* Adjusted padding */
            font-family: 'Georgia', serif;
            color: #4a2f1b;
            z-index: 1000;
            text-align: center;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            display: none; /* Hidden by default */
            max-width: 80%; /* Limit width */
        }
        
        #equippedSlots {
            display: flex;
            flex-direction: column;
            gap: 8px; /* Space between slot rows */
        }
        #equippedSlots .equipment-slot-row {
            display: flex;
            align-items: center;
            background-color: #e0d0b0;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #c0a080;
            justify-content: space-between; /* Distribute items */
        }
        #equippedSlots .equipment-slot-row.selected {
            background-color: #ffd700; /* Highlight selected row */
            color: #000;
        }
        #equippedSlots .nav-button {
            background-color: #4a2f1b; /* Darker brown for buttons */
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.2s;
            margin: 0 2px;
        }
        #equippedSlots .nav-button:hover {
            background-color: #6a4a2b;
        }

        #equipmentMenuButtons {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
        }
        #equipmentMenuButtons button {
            background-color: #4CAF50; /* Green for Save */
            color: white;
            border: 2px solid #388E3C;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        #equipmentMenuButtons button:hover {
            background-color: #66BB6A;
        }
        #equipmentMenuButtons button:last-child {
            background-color: #F44336; /* Red for Back */
            border: 2px solid #D32F2F;
        }
        #equipmentMenuButtons button:last-child:hover {
            background-color: #EF5350;
        }
    </style>
</head>
<body>
    <div id="difficultyScreen">
        <h2 id="difficultyTitle">Selecciona la Dificultad</h2>
        <div id="lastScoreDisplay"></div>
        <button id="btnFacil">Fácil</button>
        <button id="btnMedio">Medio</button>
        <button id="btnDificil">Difícil</button>
        <button id="btnEquipment">Equipo</button> <!-- New button for equipment menu -->
        <div id="debugControls">
            <label for="levelInput">Nivel Base:</label>
            <input type="number" id="levelInput" min="1" value="1">
            <button id="btnGoToFloor">Ir</button>
        </div>
    </div>

    <canvas id="gameCanvas" width="500" height="500"></canvas>
    <canvas id="minimapCanvas"></canvas>
    
    <div id="inventoryMenu">
        <h2>Inventario</h2>
        <p>Oro: <span id="playerGoldInventory">0</span></p>
        <ul id="gearList"></ul>
    </div>
    <div id="skillMenu">
        <h2>Habilidades</h2>
        <p><span id="skillPoints">0</span></p>
        <ul id="skillList"></ul>
    </div>
    <div id="equipmentMenu"> 
        <h2>Equipo</h2>
        <div id="equippedSlots">
            <!-- Equipped items will be displayed here dynamically with buttons -->
        </div>
        <p id="equipmentMenuInstructions"></p>
        <div id="equipmentMenuButtons">
            <button id="btnSaveEquipment">Guardar</button>
            <button id="btnReturnToDifficulty">Regresar</button>
        </div>
    </div>

    <div id="messageBox"></div> <!-- New message box element -->

    <audio id="audioDungeon1" src="https://richardericpp.github.io/Notion_Leveling/2.Music/1.%20-%20Solo%20LevelingSymphonicSuite%20Lv.1.mp3" loop preload="auto" volume="0.1"></audio>
    <audio id="audioDungeon2" src="https://richardericpp.github.io/Notion_Leveling/2.Music/2.%20-%20%5BSolo-Leveling%5DSymphonicSuite-Lv.2%20-%20OST_AnimeOriginal.mp3" loop preload="auto" volume="0.1"></audio>
    <audio id="audioDungeon3" src="https://richardericpp.github.io/Notion_Leveling/2.Music/3.%20-%20%5BSolo-Leveling%5DSymphonicSuite-Lv.3.mp3" loop preload="auto" volume="0.1"></audio>
    <audio id="audioDungeon4" src="https://richardericpp.github.io/Notion_Leveling/2.Music/4.%20-%20%5BSolo-Leveling%5DSymphonicSuite-Lv.4.mp3" loop preload="auto" volume="0.1"></audio>
    <audio id="audioDungeon5" src="https://richardericpp.github.io/Notion_Leveling/2.Music/5.%20-%20%5BSolo-Leveling%5DSymphonicSuite-Lv.5.mp3" loop preload="auto" volume="0.1"></audio>
    <audio id="audioDungeon6" src="https://richardericpp.github.io/Notion_Leveling/2.Music/6.%20-%20%5BSolo-Leveling%5DSymphonicSuite-Lv.6%20-%20OST_AnimeOriginal.mp3" loop preload="auto" volume="0.1"></audio>
    <audio id="audioDungeon7" src="https://richardericpp.github.io/Notion_Leveling/2.Music/7.%20-%20%5BSolo-Leveling%5DSymphonicSuite-Lv.7%20-%20OST_AnimeOriginal.mp3" loop preload="auto" volume="0.1"></audio>
    <audio id="audioDungeon8" src="https://richardericpp.github.io/Notion_Leveling/2.Music/8.%20-%20%5BSolo-Leveling%5DSymphonicSuite-Lv.8.mp3" loop preload="auto" volume="0.1"></audio>
    <audio id="audioDungeon9" src="https://richardericpp.github.io/Notion_Leveling/2.Music/9.%20-%20%5BSolo-Leveling%5DSymphonicSuite-Lv.9.mp3" loop preload="auto" volume="0.1"></audio>
    <audio id="audioDungeon10" src="https://richardericpp.github.io/Notion_Leveling/2.Music/10.%20-%20%5BSolo-Leveling%5DSymphonicSuite-Lv.10.mp3" loop preload="auto" volume="0.1"></audio>

    <!-- Final Boss Music -->
    <audio id="audioBoss" src="https://richardericpp.github.io/Notion_Leveling/2.Music/99.%20Bozz.mp3" loop preload="auto" volume="0.2"></audio>

    <!-- Equipment Open Sound (System) -->
    <audio id="audioEquipmentOpen" src="https://richardericpp.github.io/Notion_Leveling/2.Music/98.%20System.mp3" preload="auto" volume="0.5"></audio>

    <script>
        // Ensure these are the very first executable lines in the script
        let isInventoryOpen = false;
        let isSkillMenuOpen = false;
        let isEquipmentOpen = false;
        
        console.log('isInventoryOpen declared:', isInventoryOpen);
        console.log('isSkillMenuOpen declared:', isInventoryOpen);
        console.log('isEquipmentOpen declared:', isEquipmentOpen);

        let currentFloor = 1;
        const maxFloors = 4; 

        const mapWidth = 30, mapHeight = 30; 
        const tileSize = 50; 
        let map = Array(mapHeight).fill().map(() => Array(mapWidth).fill(0));
        let stairLocation = { x: -1, y: -1, active: false, type: 4 }; 

        let selectedDifficulty = 'medio'; 
        let gameStarted = false;
        let hpMultiplier = 1.0;
        let atkMultiplier = 1.0;
        let lastGameScore = 0;
        let lastEnemiesDefeated = 0;
        let finalOutcomeMessage = ""; 
        let finalOutcomeMessageLine2 = "";


        // Gear list definition with item levels and stats
        const gearList = [
            
            { name: 'Casco de Hierro', type: 'helmet', def: 3, itemLevel: 1, baseValue: 20, set: 'Hierro' },
            { name: 'Casco de Caballero', type: 'helmet', def: 5, spd: 2, itemLevel: 2, baseValue: 40, set: 'Caballero' },
            { name: 'Casco de Demonio', type: 'helmet', def: 7, atk: 3, itemLevel: 3, baseValue: 60, set: 'Demonio' },
            { name: 'Casco de León', type: 'helmet', def: 8, itemLevel: 3, baseValue: 55, set: 'León' },
            { name: 'Casco de Asesinato', type: 'helmet', spd: 4, critical: 0.03, itemLevel: 3, baseValue: 70, set: 'Asesinato' }, 
            { name: 'Casco Noble', type: 'helmet', def: 4, itemLevel: 2, baseValue: 30, set: 'Noble' },
            { name: 'Casco de Mago', type: 'helmet', def: 3, itemLevel: 1, baseValue: 25, set: 'Mago' },

            { name: 'Armadura de Hierro', type: 'armor', def: 6, itemLevel: 1, baseValue: 40, set: 'Hierro' },
            { name: 'Armadura de Caballero', type: 'armor', def: 8, spd: 2, itemLevel: 2, baseValue: 70, set: 'Caballero' },
            { name: 'Armadura de Demonio', type: 'armor', def: 10, atk: 4, itemLevel: 3, baseValue: 100, set: 'Demonio' },
            { name: 'Armadura de León', type: 'armor', def: 9, itemLevel: 3, baseValue: 90, set: 'León' },
            { name: 'Armadura de Asesinato', type: 'armor', spd: 6, critical: 0.04, itemLevel: 3, baseValue: 110, set: 'Asesinato' }, 
            { name: 'Armadura Noble', type: 'armor', def: 7, itemLevel: 2, baseValue: 60, set: 'Noble' },
            { name: 'Armadura de Mago', type: 'armor', def: 5, itemLevel: 1, baseValue: 50, set: 'Mago' },

            { name: 'Guantes de Hierro', type: 'gloves', atk: 3, itemLevel: 1, baseValue: 15, set: 'Hierro' },
            { name: 'Guantes de Caballero', type: 'gloves', atk: 4, def: 1, itemLevel: 2, baseValue: 30, set: 'Caballero' },
            { name: 'Guantes de Demonio', type: 'gloves', atk: 6, spd: 2, itemLevel: 3, baseValue: 50, set: 'Demonio' },
            { name: 'Guantes de León', type: 'gloves', atk: 5, itemLevel: 3, baseValue: 45, set: 'León' },
            { name: 'Guantes de Asesinato', type: 'gloves', critical: 0.05, spd: 3, itemLevel: 3, baseValue: 60, set: 'Asesinato' }, 
            { name: 'Guantes de Noble', type: 'gloves', atk: 3, itemLevel: 2, baseValue: 25, set: 'Noble' },
            { name: 'Guantes de Mago', type: 'gloves', spd: 2, itemLevel: 1, baseValue: 20, set: 'Mago' },

            { name: 'Botas de Hierro', type: 'boots', spd: 3, itemLevel: 1, baseValue: 20, set: 'Hierro' },
            { name: 'Botas de Caballero', type: 'boots', spd: 5, def: 1, itemLevel: 2, baseValue: 40, set: 'Caballero' },
            { name: 'Botas de Demonio', type: 'boots', spd: 7, atk: 2, itemLevel: 3, baseValue: 60, set: 'Demonio' },
            { name: 'Botas de León', type: 'boots', spd: 8, itemLevel: 3, baseValue: 55, set: 'León' },
            { name: 'Botas de Asesinato', type: 'boots', spd: 9, itemLevel: 3, baseValue: 70, set: 'Asesinato' },
            { name: 'Botas de Noble', type: 'boots', spd: 4, itemLevel: 2, baseValue: 30, set: 'Noble' },
            { name: 'Botas de Mago', type: 'boots', spd: 6, itemLevel: 1, baseValue: 25, set: 'Mago' },

            { name: 'Escudo Colosal', type: 'weapon', def: 10, itemLevel: 2, baseValue: 80, set: 'Hierro', attackSpeed: 400 }, 
            { name: 'Maza de Guerra', type: 'weapon', atk: 9, itemLevel: 2, baseValue: 75, set: 'Caballero', attackSpeed: 400 },
            { name: 'Espada de Luz', type: 'weapon', atk: 7, spd: 3, itemLevel: 3, baseValue: 90, set: 'Demonio', attackSpeed: 250 },
            { name: 'Libro Celestial', type: 'weapon', atk: 5, spd: 4, itemLevel: 3, baseValue: 85, set: 'Mago', attackSpeed: 400 }, 
            { name: 'Rayo de Oscuridad', type: 'weapon', atk: 7, critical: 0.03, itemLevel: 3, baseValue: 95, set: 'Asesinato', attackSpeed: 400 }, 
            { name: 'Daga de Poder', type: 'weapon', atk: 6, spd: 4, itemLevel: 1, baseValue: 50, set: 'Asesinato', attackSpeed: 400 },
            { name: 'Arco del Bosque', type: 'weapon', atk: 6, critical: 0.04, itemLevel: 2, baseValue: 70, set: 'León', attackSpeed: 400 }, 
            { name: 'Guadaña Helada', type: 'weapon', atk: 8, itemLevel: 2, baseValue: 80, set: 'Noble', attackSpeed: 400 },
        ];

        // Player definition
        let player = {
            tileX: 1,
            tileY: 1,
            hp: 100,
            maxHp: 100,
            atk: 5, 
            def: 5, 
            spd: 4, 
            xp: 0,
            level: 1,
            skillPoints: 0,
            inventory: [], 
            equipped: { 
                helmet: null, 
                armor: null, 
                gloves: null, 
                boots: null, 
                weapon: null, 
                habilidad1: null, 
                habilidad2: null, 
                habilidad3: null  
            },
            unlockedSkills: [], 
            permanentlyLearnedSkills: [], 
            hasKey: false,
            facingDirection: 'right', 
            hitFrame: 0, 
            doorOpened: false, 
            lastHitTime: 0,
            invulnerabilityTime: 500,
            isAttacking: false, 
            attackAnimFrame: 0, 
            attackAnimDuration: 7, 
            attackLungeDistance: tileSize / 4,
            skillUsageThisFloor: {},
            enemiesDefeatedThisRun: 0,
            gold: 0, 
            isSlowed: false,
            slowEndTime: 0,
            potionsBoughtTotal: 0,
            isStealthed: false,
            stealthEndTime: 0,
            stealthActive: false, 
            stealthStatMultiplier: 1.0, 
            nextHitCritical: false,
            isInvincible: false,
            invincibleEndTime: 0,
            isSpeedBoosted: false,
            speedBoostEndTime: 0,
            luckBoostEndTime: 0,
            soulExtractionActive: false,
            furyActive: false, 
            baseSpd: 4, 
            baseAtk: 5, 
            baseDef: 5, 
            criticalChanceBonus: 0,
            celestialBookCritCounter: 0, 
            hasMiniShield: false, 
            miniShieldHP: 0, 
            miniShieldMaxHP: 0, 
            miniShieldCooldownEnd: 0, 
            darkRayEnemiesDefeated: 0 
        };

        const sprites = {}; 
        const loadedImages = {}; 

        // --- Funciones de Creación de Sprites ---
        function createPlayerSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // Define set-specific colors
            const setColors = {
                'Hierro': { main: '#607d8b', detail: '#b0bec5' },
                'Caballero': { main: '#b71c1c', detail: '#ef9a9a' },
                'Demonio': { main: '#1a237e', detail: '#ffd700' },
                'León': { main: '#4A2F1B', detail: '#FFD700' }, // Changed to dark brown with golden touches for Lion set
                'Asesinato': { main: '#006064', detail: '#9c27b0' },
                'Noble': { main: '#212121', detail: '#ffd700' },
                'Mago': { main: '#eceff1', detail: '#ffd700' }
            };

            // Default colors for individual body parts if no specific item is equipped
            const defaultPartColors = {
                body: '#2c3e50',
                helmet: '#1a252f', 
                arm: '#2c3e50', 
                leg: '#2c3e50', 
                detail: '#7f8c8d', 
                skin: '#ffd29c',
                eyes: '#000'
            };

            let currentFullSetDetected = null;
            // Changed to 4 pieces for set bonus: helmet, armor, gloves, boots
            const fullSetPieces = ['helmet', 'armor', 'gloves', 'boots']; 
            const equippedSetNames = [];

            fullSetPieces.forEach(slot => {
                if (player.equipped[slot] && player.equipped[slot].set) {
                    equippedSetNames.push(player.equipped[slot].set);
                }
            });

            if (equippedSetNames.length === fullSetPieces.length && new Set(equippedSetNames).size === 1) {
                currentFullSetDetected = equippedSetNames[0];
            }

            // Initialize colors with defaults
            let torsoColor = defaultPartColors.body;
            let headColor = defaultPartColors.helmet;
            let armColor = defaultPartColors.arm;
            let legColor = defaultPartColors.leg;
            let detailColor = defaultPartColors.detail;
            let drawHood = true;

            if (currentFullSetDetected) {
                // If a full set is detected, all parts take that set's colors
                const set = setColors[currentFullSetDetected];
                torsoColor = set.main;
                headColor = set.main; 
                armColor = set.main;
                legColor = set.main;
                detailColor = set.detail;
                drawHood = false;
            } else {
                if (player.equipped.armor && player.equipped.armor.set) {
                    torsoColor = setColors[player.equipped.armor.set].main;
                    
                    detailColor = setColors[player.equipped.armor.set].detail; 
                }
                if (player.equipped.helmet && player.equipped.helmet.set) {
                    headColor = setColors[player.equipped.helmet.set].main;
                    drawHood = false; 
                }
                if (player.equipped.gloves && player.equipped.gloves.set) {
                    armColor = setColors[player.equipped.gloves.set].main;
                }
                if (player.equipped.boots && player.equipped.boots.set) {
                    legColor = setColors[player.equipped.boots.set].main;
                }
            }
            
            ctx.fillStyle = torsoColor; 
            ctx.fillRect(16, 16, 32, 32); 

            if (drawHood) {
                ctx.fillStyle = headColor; // Hood color
                ctx.beginPath();
                ctx.moveTo(20, 20); ctx.lineTo(18, 10); ctx.lineTo(46, 10); 
                ctx.lineTo(44, 20); ctx.lineTo(38, 22); ctx.lineTo(32, 24); 
                ctx.lineTo(26, 22); ctx.closePath(); ctx.fill();
                ctx.fillStyle = defaultPartColors.skin; // Face color
                ctx.fillRect(26, 13, 12, 7); 
                ctx.fillStyle = defaultPartColors.eyes; // Eye color
                ctx.fillRect(28, 15, 2, 2); 
                ctx.fillRect(34, 15, 2, 2); 
            } else { 
                ctx.fillStyle = headColor; // Helmet color
                ctx.fillRect(20, 8, 24, 12); 
                ctx.fillStyle = detailColor; // Helmet detail
                ctx.fillRect(22, 10, 20, 2); 
                ctx.fillStyle = defaultPartColors.skin; // Face color
                ctx.fillRect(24, 12, 16, 8); 
                ctx.fillStyle = defaultPartColors.eyes; // Eye color
                ctx.fillRect(28, 14, 2, 2); ctx.fillRect(34, 14, 2, 2);
            }
            
            ctx.fillStyle = armColor; // Left arm color
            ctx.fillRect(8, 24, 10, 16); 
            ctx.strokeStyle = detailColor; // Arm detail
            ctx.lineWidth = 2; 
            ctx.strokeRect(8, 24, 10, 16);

            ctx.fillStyle = legColor; // Leg color
            ctx.fillRect(20, 48, 10, 12); ctx.fillRect(34, 48, 10, 12); 
            ctx.fillStyle = detailColor; // Leg detail
            ctx.fillRect(20, 52, 10, 2); ctx.fillRect(34, 52, 10, 2);
            if (player.equipped.weapon) {
                switch (player.equipped.weapon.name) {
                    case 'Daga de Poder': 
                        ctx.fillStyle = '#333'; // Handle
                        ctx.fillRect(48, 20, 4, 12);
                        ctx.fillStyle = '#ADD8E6'; // Blade
                        ctx.beginPath();
                        ctx.moveTo(50, 12);
                        ctx.lineTo(46, 20);
                        ctx.lineTo(54, 20);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 'Maza de Guerra': 
                        ctx.fillStyle = '#8B4513'; ctx.fillRect(48, 16, 4, 16); // Handle
                        ctx.fillStyle = '#50C878'; // Emerald head
                        ctx.beginPath(); ctx.arc(50, 14, 8, 0, Math.PI * 2); ctx.fill(); 
                        ctx.fillStyle = '#FFD700'; // Gold detail
                        ctx.beginPath(); ctx.arc(50, 14, 4, 0, Math.PI * 2); ctx.fill();
                        // Spikes
                        ctx.fillStyle = '#408040'; // Darker emerald for spikes
                        ctx.beginPath(); ctx.moveTo(46, 8); ctx.lineTo(50, 2); ctx.lineTo(54, 8); ctx.closePath(); ctx.fill(); // Top spike
                        ctx.beginPath(); ctx.moveTo(46, 20); ctx.lineTo(50, 26); ctx.lineTo(54, 20); ctx.closePath(); ctx.fill(); // Bottom spike
                        ctx.beginPath(); ctx.moveTo(42, 14); ctx.lineTo(48, 10); ctx.lineTo(48, 18); ctx.closePath(); ctx.fill(); // Left spike
                        ctx.beginPath(); ctx.moveTo(58, 14); ctx.lineTo(52, 10); ctx.lineTo(52, 18); ctx.closePath(); ctx.fill(); // Right spike
                        break;
                    case 'Espada de Luz': 
                        ctx.fillStyle = '#ADD8E6'; ctx.fillRect(48, 16, 14, 6); // Blue blade
                        ctx.fillStyle = '#FFFFFF'; ctx.fillRect(46, 20, 18, 2); // White guard
                        ctx.fillStyle = '#4682B4'; ctx.fillRect(44, 22, 6, 8); // Handle
                        break;
                    case 'Libro Celestial': 
                        ctx.fillStyle = '#D3D3D3'; ctx.fillRect(48, 16, 12, 16); // Lead color book
                        ctx.fillStyle = '#FFD700'; ctx.fillRect(46, 18, 2, 12); // Gold spine
                        ctx.fillStyle = '#FFD700'; ctx.fillRect(58, 18, 2, 12); // Gold spine
                        ctx.fillStyle = '#FFFFFF'; ctx.font = '10px Arial'; ctx.fillText('L', 52, 26);
                        break;
                    case 'Rayo de Oscuridad':
                        ctx.fillStyle = '#8A2BE2'; ctx.fillRect(48, 18, 16, 6); // Purple ray
                        ctx.fillStyle = '#4B0082'; ctx.fillRect(44, 16, 6, 10); // Darker purple base
                        const darkGlow = ctx.createRadialGradient(56, 21, 2, 56, 21, 15);
                        darkGlow.addColorStop(0, 'rgba(138, 43, 226, 0.8)'); 
                        darkGlow.addColorStop(0.5, 'rgba(75, 0, 130, 0.5)');
                        darkGlow.addColorStop(1, 'rgba(75, 0, 130, 0)');
                        ctx.fillStyle = darkGlow; ctx.fillRect(38, 10, 36, 22); 
                        break;
                    case 'Arco del Bosque':
                        ctx.strokeStyle = '#8B4513'; ctx.lineWidth = 2; // Brown wood
                        ctx.beginPath(); ctx.arc(50, 25, 10, Math.PI * 0.7, Math.PI * 1.3, true); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(50, 15); ctx.lineTo(50, 35); ctx.stroke();
                        ctx.fillStyle = '#228B22'; ctx.beginPath(); ctx.arc(50, 15, 3, 0, Math.PI * 2); ctx.fill(); // Green leaves
                        ctx.beginPath(); ctx.arc(50, 35, 3, 0, Math.PI * 2); ctx.fill();
                        break;
                    case 'Guadaña Helada':
                        ctx.fillStyle = '#A9A9A9'; ctx.fillRect(48, 16, 4, 16); // Handle
                        ctx.fillStyle = '#87CEEB'; ctx.beginPath(); ctx.moveTo(52, 16); ctx.lineTo(60, 12); ctx.lineTo(60, 24); ctx.lineTo(52, 28); ctx.fill(); // Winter Blue Blade
                        break;
                    case 'Escudo Colosal':
                        ctx.fillStyle = '#87CEEB'; ctx.fillRect(35, 10, 25, 25); // Sky Blue Shield body (made larger)
                        ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(47.5, 22.5, 7, 0, Math.PI * 2); ctx.fill(); // Gold Central boss (scaled with shield)
                        ctx.strokeStyle = '#36454F'; ctx.lineWidth = 2; ctx.strokeRect(35, 10, 25, 25);
                        break;
                    default: ctx.fillStyle = '#d0d0d0'; ctx.fillRect(48, 20, 12, 4); ctx.fillStyle = '#ffd700'; ctx.fillRect(44, 18, 6, 8);
                }
            } else { ctx.fillStyle = '#d0d0d0'; ctx.fillRect(48, 20, 12, 4); ctx.fillStyle = '#ffd700'; ctx.fillRect(44, 18, 6, 8); }
            
            ctx.strokeStyle = '#000'; ctx.lineWidth = 1; 
            ctx.strokeRect(16, 16, 32, 32); // Torso outline
            ctx.strokeRect(20, 8, 24, 12); // Helmet outline (or top of hood)
            ctx.strokeRect(20, 48, 10, 12); // Left leg outline
            ctx.strokeRect(34, 48, 10, 12); // Right leg outline
            return canvas.toDataURL();
        }
        function createDuendeSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#2E7D32'; 
            ctx.beginPath();
            ctx.moveTo(32, 8); 
            ctx.lineTo(20, 28); 
            ctx.lineTo(44, 28); 
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#1B5E20'; 
            ctx.lineWidth = 1.5;
            ctx.stroke();

            ctx.fillStyle = '#66BB6A'; 
            ctx.beginPath();
            ctx.ellipse(32, 30, 13, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#66BB6A';
            ctx.beginPath(); 
            ctx.moveTo(19, 25); ctx.lineTo(13, 20); ctx.lineTo(19, 30); ctx.closePath(); ctx.fill();
            ctx.strokeStyle = '#4CAF50'; ctx.stroke(); 
            ctx.beginPath(); 
            ctx.moveTo(45, 25); ctx.lineTo(51, 20); ctx.lineTo(45, 30); ctx.closePath(); ctx.fill();
            ctx.stroke();

            ctx.fillStyle = '#FDD835'; 
            ctx.beginPath(); ctx.ellipse(27, 29, 4, 5, -0.1 * Math.PI, 0, Math.PI * 2); ctx.fill(); 
            ctx.beginPath(); ctx.ellipse(37, 29, 4, 5, 0.1 * Math.PI, 0, Math.PI * 2); ctx.fill(); 
            ctx.fillStyle = '#000'; 
            ctx.beginPath(); ctx.arc(27, 30, 1.5, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(37, 30, 1.5, 0, Math.PI * 2); ctx.fill();

            ctx.fillStyle = '#388E3C'; 
            ctx.fillRect(22, 38, 20, 18);
            ctx.strokeStyle = '#2E7D32';
            ctx.strokeRect(22, 38, 20, 18);

            ctx.fillStyle = '#757575'; 
            ctx.beginPath();
            ctx.moveTo(40, 40); ctx.lineTo(45, 35); ctx.lineTo(47, 37); ctx.lineTo(42, 42);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#4E342E'; 
            ctx.fillRect(41, 41, 3, 5);

            return canvas.toDataURL();
        }
        function createWolfSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');

            const bodyMain = '#B71C1C'; 
            const furRed = '#D32F2F';   
            const shadowRed = '#7F0000'; 
            const eyeColor = '#FF4500'; 
            const clawColor = '#212121'; 
            const highlightRed = '#E57373'; 

            // Tail (bushy, slightly arched, dark red with highlights)
            ctx.fillStyle = bodyMain;
            ctx.beginPath();
            ctx.moveTo(10, 40); 
            ctx.quadraticCurveTo(0, 35, 8, 25); 
            ctx.quadraticCurveTo(15, 30, 10, 40); 
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = furRed;
            ctx.beginPath();
            ctx.moveTo(11, 38); 
            ctx.quadraticCurveTo(3, 34, 9, 28); 
            ctx.quadraticCurveTo(14, 32, 11, 38);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = shadowRed;
            ctx.beginPath(); ctx.ellipse(18, 48, 6, 12, -0.25 * Math.PI, 0, Math.PI * 2); ctx.fill(); 
            ctx.beginPath(); ctx.ellipse(46, 48, 6, 12, 0.25 * Math.PI, 0, Math.PI * 2); ctx.fill();  
            
            ctx.fillStyle = bodyMain;
            ctx.beginPath(); ctx.ellipse(25, 50, 7, 13, -0.1 * Math.PI, 0, Math.PI * 2); ctx.fill(); 
            ctx.beginPath(); ctx.ellipse(39, 50, 7, 13, 0.1 * Math.PI, 0, Math.PI * 2); ctx.fill();  

            ctx.fillStyle = bodyMain;
            ctx.beginPath();
            ctx.ellipse(32, 40, 20, 14, 0, 0, Math.PI * 2); 
            ctx.fill();
            
            ctx.fillStyle = furRed;
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.moveTo(18 + i * 7, 30); 
                ctx.lineTo(21 + i * 7, 22 - Math.random()*3); 
                ctx.lineTo(24 + i * 7, 30);
                ctx.closePath();
                ctx.fill();
            }

            ctx.fillStyle = bodyMain;
            ctx.beginPath();
            ctx.ellipse(50, 29, 13, 9, -0.1 * Math.PI, 0, Math.PI * 2); 
            ctx.fill();
            ctx.fillStyle = highlightRed; 
            ctx.beginPath();
            ctx.ellipse(54, 26, 6, 3, -0.1 * Math.PI, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = shadowRed; 
            ctx.beginPath();
            ctx.ellipse(59, 23, 3.5, 2.5, -0.1 * Math.PI, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = shadowRed;
            ctx.beginPath(); 
            ctx.moveTo(43, 20); ctx.lineTo(39, 8); ctx.lineTo(47, 17); ctx.closePath(); ctx.fill();
            ctx.beginPath(); 
            ctx.moveTo(57, 20); ctx.lineTo(53, 8); ctx.lineTo(61, 17); ctx.closePath(); ctx.fill();
            
            ctx.fillStyle = eyeColor;
            ctx.shadowColor = eyeColor;
            ctx.shadowBlur = 5;
            ctx.beginPath(); ctx.ellipse(46, 28, 3.5, 2.5, 0,0, Math.PI*2); ctx.fill(); 
            ctx.beginPath(); ctx.ellipse(55, 28, 3.5, 2.5, 0,0, Math.PI*2); ctx.fill(); 
            ctx.shadowBlur = 0; 

            // Claws
            ctx.fillStyle = clawColor;
            ctx.beginPath(); ctx.moveTo(20,59); ctx.lineTo(18,63); ctx.lineTo(22,61); ctx.closePath(); ctx.fill(); 
            ctx.beginPath(); ctx.moveTo(34,59); ctx.lineTo(32,63); ctx.lineTo(36,61); ctx.closePath(); ctx.fill(); 
            
            return canvas.toDataURL();
        }
        function createSkeletonSprite() { const c = document.createElement('canvas'); c.width=64;c.height=64; const x=c.getContext('2d'); x.fillStyle = '#f0f0f0';x.fillRect(28,24,8,24);x.fillRect(20,32,24,4);x.fillRect(20,38,24,4);x.beginPath();x.ellipse(32,16,10,12,0,0,Math.PI*2);x.fill();x.fillStyle = '#000';x.beginPath();x.ellipse(28,14,3,4,0,0,Math.PI*2);x.fill();x.beginPath();x.ellipse(36,14,3,4,0,0,Math.PI*2);x.fill();x.fillStyle = '#f0f0f0';x.beginPath();x.ellipse(32,22,8,4,0,0,Math.PI);x.fill();x.strokeStyle = '#000';x.lineWidth = 1;x.beginPath();x.moveTo(24,22);x.lineTo(40,22);x.stroke();x.fillStyle = '#f0f0f0';x.fillRect(16,32,12,4);x.fillRect(36,32,12,4);x.fillRect(24,48,4,12);x.fillRect(36,48,4,12);x.fillStyle = '#a0a0a0';x.fillRect(48,28,12,2);x.fillStyle = '#8b4513';x.fillRect(44,27,4,4); return c.toDataURL(); }
        function createMiniBossSprite() { const c = document.createElement('canvas'); c.width=64;c.height=64; const x=c.getContext('2d'); x.fillStyle = '#ff6600';x.beginPath();x.ellipse(32,32,20,24,0,0,Math.PI*2);x.fill();x.beginPath();x.ellipse(32,16,14,12,0,0,Math.PI*2);x.fill();x.fillStyle = '#ffff00';x.beginPath();x.ellipse(26,14,4,4,0,0,Math.PI*2);x.fill();x.beginPath();x.ellipse(38,14,4,4,0,0,Math.PI*2);x.fill();x.fillStyle = '#000';x.beginPath();x.ellipse(26,14,2,2,0,0,Math.PI*2);x.fill();x.beginPath();x.ellipse(38,14,2,2,0,0,Math.PI*2);x.fill();x.beginPath();x.ellipse(32,22,8,4,0,0,Math.PI);x.fill();x.fillStyle = '#8b4513';x.beginPath();x.moveTo(22,10);x.lineTo(18,2);x.lineTo(26,8);x.fill();x.beginPath();x.moveTo(42,10);x.lineTo(46,2);x.lineTo(38,8);x.fill();x.fillStyle = '#8b4513';x.fillRect(48,28,4,16);x.fillStyle = '#a0a0a0';x.beginPath();x.moveTo(52,28);x.lineTo(60,22);x.lineTo(60,34);x.lineTo(52,28);x.fill(); return c.toDataURL(); }
        function createBossSprite() { const c = document.createElement('canvas'); c.width=64;c.height=64; const x=c.getContext('2d'); x.fillStyle = '#990000';x.fillRect(12,12,40,40);x.fillStyle = '#cc0000';x.beginPath();x.ellipse(32,20,16,10,0,0,Math.PI*2);x.fill();x.fillStyle = '#ffff00';x.beginPath();x.ellipse(24,18,5,5,0,0,Math.PI*2);x.fill();x.beginPath();x.ellipse(40,18,5,5,0,0,Math.PI*2);x.fill();x.fillStyle = '#000';x.beginPath();x.ellipse(24,18,2,3,0,0,Math.PI*2);x.fill();x.beginPath();x.ellipse(40,18,2,3,0,0,Math.PI*2);x.fill();x.beginPath();x.ellipse(32,26,10,4,0,0,Math.PI);x.fill();x.fillStyle = '#fff';for(let i=0;i<5;i++){x.beginPath();x.moveTo(24+i*4,26);x.lineTo(26+i*4,26);x.lineTo(25+i*4,30);x.fill();}x.fillStyle = '#660000';x.fillRect(12,32,40,4);x.fillRect(12,42,40,4);x.fillStyle = '#000';x.fillRect(52,20,4,24);x.fillStyle = '#a0a0a0';x.beginPath();x.moveTo(54,12);x.lineTo(60,20);x.lineTo(48,20);x.fill(); return c.toDataURL(); }
        function createArachnidBossSprite() { 
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64; 
            const ctx = canvas.getContext('2d');
            const bodyColor = '#3A1E00'; 
            const legColor = '#2A1B00';
            const eyeColor = '#FF0000'; 
            const highlightColor = '#5C3601';

            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.ellipse(32, 32, 20, 15, 0, 0, Math.PI * 2); 
            ctx.fill();
            ctx.fillStyle = highlightColor;
            ctx.beginPath();
            ctx.ellipse(32, 30, 18, 12, 0, 0, Math.PI * 2); 
            ctx.fill();

            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.ellipse(32, 18, 10, 7, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = eyeColor;
            ctx.beginPath(); ctx.arc(28, 17, 3, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(36, 17, 3, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(25, 21, 2.5, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(39, 21, 2.5, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(32, 22, 2.5, 0, Math.PI*2); ctx.fill();


            ctx.strokeStyle = legColor;
            ctx.lineWidth = 6;
            const legSegments = (startX, startY, midX, midY, endX, endY) => {
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.quadraticCurveTo(midX, midY, endX, endY);
                ctx.stroke();
            };

            legSegments(25, 30, 10, 20, 5, 10);
            legSegments(22, 35, 5, 35, 0, 38);
            legSegments(22, 40, 5, 45, 0, 50);
            legSegments(25, 45, 10, 55, 5, 60);
            legSegments(39, 30, 54, 20, 59, 10);
            legSegments(42, 35, 59, 35, 64, 38);
            legSegments(42, 40, 59, 45, 64, 50);
            legSegments(39, 45, 54, 55, 59, 60);
            
            return canvas.toDataURL();
        }
            function createSpiderlingSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const bodyColor = '#4A2A05'; 
            const legColor = '#3B2304';
            const eyeColor = '#FF4500';

            ctx.fillStyle = bodyColor;
            ctx.beginPath();
            ctx.ellipse(32, 32, 8, 6, 0, 0, Math.PI * 2); 
            ctx.fill();

            ctx.fillStyle = eyeColor;
            ctx.beginPath(); ctx.arc(29, 30, 2, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(35, 30, 2, 0, Math.PI*2); ctx.fill();

            ctx.strokeStyle = legColor;
            ctx.lineWidth = 3;
            const leg = (sx, sy, mx, my, ex, ey) => { ctx.beginPath(); ctx.moveTo(sx,sy); ctx.quadraticCurveTo(mx,my,ex,ey); ctx.stroke();};
            leg(28,32, 20,28, 15,25); leg(27,34, 18,34, 13,34); leg(27,36, 18,38, 13,40); leg(28,38, 20,42, 15,45);
            leg(36,32, 44,28, 49,25); leg(37,34, 46,34, 51,34); leg(37,36, 46,38, 51,40); leg(36,38, 44,42, 49,45);
            return canvas.toDataURL();
        }
        function createStairsSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#4A3B31'; 
            for (let i = 0; i < 5; i++) {
                ctx.fillRect(8 + i * 8, 8 + i * 8, 48 - i * 16, 8);
            }
            ctx.strokeStyle = '#3A2F28';
            ctx.lineWidth = 1;
            for (let i = 0; i < 5; i++) {
                ctx.strokeRect(8 + i * 8, 8 + i * 8, 48 - i * 16, 8);
            }
            const gradient = ctx.createRadialGradient(32, 48, 5, 32, 48, 15);
            gradient.addColorStop(0, 'rgba(100, 100, 200, 0.6)');
            gradient.addColorStop(1, 'rgba(100, 100, 200, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 32, 64, 32);
            return canvas.toDataURL();
        }
        function createFloorSprite() { if (sprites.floor) return sprites.floor; const c=document.createElement('canvas');c.width=64;c.height=64;const x=c.getContext('2d');x.fillStyle='#aaa';x.fillRect(0,0,64,64);x.strokeStyle='#888';x.lineWidth=1;for(let y=8;y<64;y+=16){x.beginPath();x.moveTo(0,y);x.lineTo(64,y);x.stroke();}for(let X=8;X<64;X+=16){x.beginPath();x.moveTo(X,0);x.lineTo(X,64);x.stroke();}x.strokeStyle='#777';const p=[{x:12,y:15,l:10,a:0.5},{x:32,y:24,l:8,a:1.2},{x:48,y:40,l:12,a:2.1},{x:20,y:52,l:9,a:3.6},{x:52,y:8,l:11,a:5.2}];for(const k of p){x.beginPath();x.moveTo(k.x,k.y);x.lineTo(k.x+Math.cos(k.a)*k.l,k.y+Math.sin(k.a)*k.l);x.stroke();}return c.toDataURL(); }
        function createWallSprite() { if (sprites.wall) return sprites.wall; const c=document.createElement('canvas');c.width=64;c.height=64;const x=c.getContext('2d');x.fillStyle='#555';x.fillRect(0,0,64,64);x.strokeStyle='#333';x.lineWidth=2;for(let y=16;y<64;y+=16){x.beginPath();x.moveTo(0,y);x.lineTo(64,y);x.stroke();}for(let r=0;r<4;r++){const o=r%2===0?0:16;for(let X=o;X<64;X+=32){x.beginPath();x.moveTo(X,r*16);x.lineTo(X,r*16+16);x.stroke();}}x.fillStyle='#444';const d=[{x:10,y:8,r:1.5},{x:25,y:12,r:2},{x:40,y:7,r:1.2},{x:55,y:10,r:1.8},{x:15,y:22,r:1.3},{x:30,y:26,r:2.2},{x:48,y:24,r:1.7},{x:8,y:38,r:1.9},{x:22,y:42,r:1.4},{x:38,y:40,r:2.1},{x:52,y:44,r:1.6},{x:12,y:56,r:1.8},{x:28,y:58,r:1.5},{x:44,y:54,r:2},{x:58,y:60,r:1.7},{x:18,y:5,r:1.3},{x:34,y:32,r:1.9},{x:50,y:18,r:1.4},{x:5,y:48,r:2.2},{x:60,y:36,r:1.6}];for(const k of d){x.beginPath();x.arc(k.x,k.y,k.r,0,Math.PI*2);x.fill();}return c.toDataURL(); }
        function createChestSprite() { const c = document.createElement('canvas');c.width=64;c.height=64;const x=c.getContext('2d');x.fillStyle = '#8B4513';x.fillRect(12,20,40,30);x.fillStyle = '#A0522D';x.fillRect(12,20,40,10);x.fillStyle = '#555';x.fillRect(12,30,40,4);x.fillRect(12,40,40,4);x.fillStyle = '#FFD700';x.fillRect(28,28,8,8);x.fillStyle = '#000';x.beginPath();x.arc(32,32,2,0,Math.PI*2);x.fill();x.fillStyle = 'rgba(255,255,255,0.2)';x.fillRect(14,22,36,2);return c.toDataURL(); }
        
        function createMinionSprite(playerImage) {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');

            ctx.drawImage(playerImage, 0, 0);
            
            ctx.globalCompositeOperation = 'source-atop'; 
            ctx.fillStyle = 'rgba(0, 0, 0, 1)'; 
            ctx.fillRect(0, 0, canvas.width, canvas.height); 
            ctx.globalCompositeOperation = 'source-over'; 
            
            ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
            ctx.shadowBlur = 10;
            ctx.strokeStyle = 'rgba(50, 50, 50, 0.8)';
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, canvas.width, canvas.height); 
            ctx.shadowBlur = 0;

            return canvas.toDataURL();
        }

        function loadSprites() {
            // Create and load player sprite first
            sprites.player = createPlayerSprite();
            loadedImages.player = new Image();
            loadedImages.player.src = sprites.player;
            loadedImages.player.onload = () => {
                // Once player sprite is loaded, then create and load minion sprite
                sprites.minion = createMinionSprite(loadedImages.player); 
                loadedImages.minion = new Image();
                loadedImages.minion.src = sprites.minion;
                loadedImages.minion.onload = () => { /* console.log('minion sprite loaded'); */ };
                loadedImages.minion.onerror = () => { console.error('Error loading minion sprite'); };

                for (const key in sprites) {
                    if (key === 'player' || key === 'minion') continue; 
                    if (!loadedImages[key] || sprites[key] !== loadedImages[key].src) {
                        loadedImages[key] = new Image();
                        loadedImages[key].src = sprites[key];
                        loadedImages[key].onload = () => { /* console.log(`${key} sprite loaded`); */ };
                        loadedImages[key].onerror = () => { console.error(`Error loading ${key} sprite`); };
                    }
                }
            };
            loadedImages.player.onerror = () => { console.error('Error loading player sprite'); };

            // Initialize other sprites' data URLs, but their loading into loadedImages happens in the onload of player
            if (!sprites.duende) sprites.duende = createDuendeSprite();
            if (!sprites.lobo) sprites.lobo = createWolfSprite();
            if (!sprites.skeleton) sprites.skeleton = createSkeletonSprite();
            if (!sprites.miniBoss) sprites.miniBoss = createMiniBossSprite();
            if (!sprites.boss) sprites.boss = createBossSprite();
            if (!sprites.finalBoss) sprites.finalBoss = createArachnidBossSprite(); 
            if (!sprites.spiderling) sprites.spiderling = createSpiderlingSprite(); 
            if (!sprites.floor) sprites.floor = createFloorSprite();
            if (!sprites.wall) sprites.wall = createWallSprite();
            if (!sprites.chest) sprites.chest = createChestSprite();
            if (!sprites.stairs) sprites.stairs = createStairsSprite(); 
        }


        let spellEffects = { powerStrike: 0, healingSpell: 0, fireball: 0 }; 
        let projectiles = [];
        let skillCooldowns = {};
        let attackInterval = 400; // Base attack interval
        const fixedProjectileSpeed = 0.15; // Adjusted: 0.15 tiles per frame for slower projectiles

        class Projectile {
            constructor(x, y, dx, dy, type, owner = 'player', damage = 0, isCritical = false, maxRangeTiles = 1) { 
                this.x = x; this.y = y;
                this.initialX = x; 
                this.initialY = y;

                // Normalize dx and dy to ensure consistent speed
                const magnitude = Math.sqrt(dx * dx + dy * dy);
                if (magnitude > 0) {
                    this.dx = (dx / magnitude) * fixedProjectileSpeed; 
                    this.dy = (dy / magnitude) * fixedProjectileSpeed; 
                } else {
                    this.dx = 0;
                    this.dy = 0;
                }

                this.type = type; 
                this.owner = owner; 
                this.damage = damage;
                this.isCritical = isCritical;
                this.maxRangeTiles = maxRangeTiles; 
                this.distanceTraveled = 0; 
            }
            update() {
                this.x += this.dx; 
                this.y += this.dy; 
                
                // Calculate distance traveled from initial point
                this.distanceTraveled = Math.sqrt(Math.pow(this.x - this.initialX, 2) + Math.pow(this.y - this.initialY, 2));

                // Remove projectile if it exceeds max range
                if (this.distanceTraveled > this.maxRangeTiles) {
                    return false;
                }
                return true; 
            }
        }

        // New skill definitions (These are the master definitions for skills)
        const skills = [
            { name: 'Sigilo', effect: 'Te vuelves uno con las sombras, imperceptible para los monstruos durante 7 segundos.', cooldown: 15000 },
            { name: 'Golpe Crítico', effect: 'El siguiente golpe que asestes será un 50% más devastador.', cooldown: 5000 },
            { name: 'Teletransportación', effect: 'Desplázate instantáneamente a un punto aleatorio del mapa.', cooldown: 10000 },
            { name: 'Invocar', effect: 'Manifiesta un súbdito leal con el 25% de tus estadísticas.', cooldown: 20000 },
            { name: 'Regeneración', effect: 'Restaura el 50% de tu salud máxima al instante.', cooldown: 10000 },
            { name: 'Velocidad', effect: 'Incrementa tu velocidad de movimiento en un 10% durante 5 segundos.', cooldown: 8000 },
            { name: 'Invencible', effect: 'Te vuelves inmune a todo daño durante 3 segundos.', cooldown: 25000 },
            { name: 'Rayo de Hielo', effect: 'Congela a un enemigo en su lugar durante 5 segundos.', cooldown: 12000 },
            { name: 'Suerte', effect: 'Aumenta tu probabilidad de asestar un golpe crítico en un 5% durante 10 segundos.', cooldown: 15000 },
            { name: 'Debilidad', effect: 'Reduce la resistencia de los enemigos cercanos en un 5% durante 8 segundos.', cooldown: 10000 },
            { name: 'Furia', effect: 'Duplica tu ataque cuando tu salud desciende al 25% o menos (pasiva).', cooldown: 0 }, 
            { name: 'Extracción de Almas', effect: 'Recupera salud por cada 5 golpes exitosos que asestes (pasiva).', cooldown: 0 } 
        ];

        function activateSkill(skillName) {
            const skill = skills.find(s => s.name === skillName);
            if (!skill) return;

            const isSkillEquipped = player.equipped.habilidad1 === skillName ||
                                    player.equipped.habilidad2 === skillName ||
                                    player.equipped.habilidad3 === skillName;

            if (player.skillUsageThisFloor[skillName]) {
                showMessage("Ya has usado esta habilidad en este piso.");
                return;
            }
            const currentTime = Date.now();
            if (skillCooldowns[skillName] && skillCooldowns[skillName] > currentTime) {
                showMessage(`Habilidad en enfriamiento. Tiempo restante: ${((skillCooldowns[skill.name] - currentTime) / 1000).toFixed(1)}s`);
                return;
            }

            switch (skillName) {
                case 'Sigilo':
                    player.stealthActive = true; 
                    player.stealthEndTime = currentTime + 7000; 
                    player.stealthStatMultiplier = 0.5; // 50% reduction
                    updateStats(); 
                    showMessage("¡Te has vuelto sigiloso!");
                    break;
                case 'Golpe Crítico':
                    player.nextHitCritical = true;
                    showMessage("¡Tu próximo golpe será crítico!");
                    break;
                case 'Teletransportación':
                    let newX, newY;
                    let attempts = 0;
                    do {
                        newX = Math.floor(Math.random() * mapWidth);
                        newY = Math.floor(Math.random() * mapHeight);
                        attempts++;
                    } while (map[newY][newX] !== 1 && attempts < 100); 
                    if (map[newY][newX] === 1) {
                        player.tileX = newX;
                        player.tileY = newY;
                        showMessage("¡Teletransportación exitosa!");
                    } else {
                        showMessage("No se pudo teletransportar a un lugar seguro.");
                    }
                    break;
                case 'Invocar':
                    const minionHp = Math.floor(player.maxHp * 0.25);
                    const minionAtk = Math.floor(player.atk * 0.25);
                    const minionSpd = player.spd * 0.75; 
                    
                    let spawnX = player.tileX;
                    let spawnY = player.tileY;
                    let foundSpot = false;
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const checkX = player.tileX + dx;
                            const checkY = player.tileY + dy;
                            if (checkX >= 0 && checkX < mapWidth && checkY >= 0 && checkY < mapHeight &&
                                map[checkY][checkX] === 1 &&
                                !monsters.some(m => m.tileX === checkX && m.tileY === checkY)) {
                                spawnX = checkX;
                                spawnY = checkY;
                                foundSpot = true;
                                break;
                            }
                        }
                        if (foundSpot) break;
                    }
                    if (foundSpot) {
                        monsters.push({ type: 'minion', hp: minionHp, maxHp: minionHp, atk: minionAtk, spd: minionSpd, tileX: spawnX, tileY: spawnY, xp: 0, lastMoveTime: 0, hitFrame: 0, isMinion: true, lastAttackTime: 0, spawnTime: currentTime, duration: 30000 }); 
                        showMessage("¡Un súbdito leal ha sido invocado!");
                    } else {
                        showMessage("No hay espacio para invocar un súbdito.");
                    }
                    break;
                case 'Regeneración':
                    const healedAmount = Math.floor(player.maxHp * 0.5);
                    player.hp = Math.min(player.maxHp, player.hp + healedAmount);
                    showMessage(`¡Has regenerado ${healedAmount} HP!`);
                    break;
                case 'Velocidad':
                    player.isSpeedBoosted = true;
                    player.speedBoostEndTime = currentTime + 5000; 
                    player.spd *= 1.5; 
                    showMessage("¡Velocidad aumentada!");
                    break;
                case 'Invencible':
                    player.isInvincible = true;
                    player.invincibleEndTime = currentTime + 3000; 
                    showMessage("¡Eres invencible!");
                    break;
                case 'Rayo de Hielo':
                    let nearestMonster = null;
                    let minDist = Infinity;
                    monsters.filter(m => !m.isMinion).forEach(m => {
                        const dist = Math.abs(player.tileX - m.tileX) + Math.abs(player.tileY - m.tileY);
                        if (dist < minDist && dist > 0) { 
                            minDist = dist;
                            nearestMonster = m;
                        }
                    });
                    if (nearestMonster) {
                        nearestMonster.isFrozen = true;
                        nearestMonster.frozenEndTime = currentTime + 5000; 
                        showMessage(`¡${nearestMonster.type} ha sido congelado!`);
                    } else {
                        showMessage("No hay enemigos cerca para congelar.");
                    }
                    break;
                case 'Suerte':
                    player.luckBoostEndTime = currentTime + 10000; 
                    showMessage("¡Tu suerte ha aumentado!");
                    break;
                case 'Debilidad':
                    monsters.filter(m => !m.isMinion).forEach(m => {
                        const dist = Math.abs(player.tileX - m.tileX) + Math.abs(player.tileY - m.tileY);
                        if (dist <= 3) { 
                            m.isWeakened = true;
                            m.weaknessEndTime = currentTime + 8000; 
                            showMessage(`¡${m.type} ha sido debilitado!`);
                        }
                    });
                    if (!monsters.some(m => !m.isMinion && Math.abs(player.tileX - m.tileX) + Math.abs(player.tileY - m.tileY) <= 3)) {
                        showMessage("No hay enemigos cerca para debilitar.");
                    }
                    break;
                case 'Furia': 
                    player.furyActive = true;
                    showMessage("Habilidad Furia activada (pasiva).");
                    break;
                case 'Extracción de Almas': 
                    player.soulExtractionActive = true;
                    showMessage("Habilidad Extracción de Almas activada (pasiva).");
                    break;
            }
            if (skill.cooldown > 0) {
                skillCooldowns[skill.name] = currentTime + skill.cooldown;
            }
            if (skill.cooldown !== 0) { 
                player.skillUsageThisFloor[skill.name] = true; 
            }
        }
        let monsters = [];
        let chests = [];

        function generateFloor() {
            map = Array(mapHeight).fill(0).map(() => Array(mapWidth).fill(0)); 
            stairLocation = { x: -1, y: -1, active: false, type: 4 };
            player.skillUsageThisFloor = {}; 

            if (currentFloor === maxFloors) { 
                const arenaWidth = 15; 
                const arenaHeight = 15;
                const arenaX = Math.floor((mapWidth - arenaWidth) / 2);
                const arenaY = Math.floor((mapHeight - arenaHeight) / 2);

                for (let y = 0; y < mapHeight; y++) { 
                    for (let x = 0; x < mapWidth; x++) {
                        map[y][x] = 0;
                    }
                }
                for (let y = arenaY; y < arenaY + arenaHeight; y++) { 
                    for (let x = arenaX; x < arenaX + arenaWidth; x++) {
                        map[y][x] = 1; 
                    }
                }
                player.tileX = arenaX + Math.floor(arenaWidth / 2);
                player.tileY = arenaY + arenaHeight - 2; 

                const bossSpawnX = arenaX + Math.floor(arenaWidth / 2) -1; 
                const bossSpawnY = arenaY + 1;
                
                let finalBossBaseHp = 350; let finalBossBaseAtk = 70;
                let fbHp = Math.floor(finalBossBaseHp * (1 + (currentFloor - 1) * 0.6) * hpMultiplier);
                let fbAtk = Math.floor(finalBossBaseAtk * (1 + (currentFloor - 1) * 0.4) * atkMultiplier);
                monsters.push({ type: 'final-arachnid-boss', hp: fbHp, maxHp: fbHp, atk: fbAtk, spd: 0.7, tileX: bossSpawnX, tileY: bossSpawnY, xp: 5000, lastMoveTime: 0, hitFrame: 0, width: 2, height: 2, abilityCooldowns: {webShot:0, summon:0}, lastAttackTime: 0 }); 
                for(let r=0; r<2; r++) { for(let c=0; c<2; c++) { map[bossSpawnY+r][bossSpawnX+c] = 1;}}

            } else { 
                const rooms = [];
                const numRooms = Math.floor(Math.random() * 3) + 8; 
                const minRoomSize = 4;
                const maxRoomSize = 7; 

                for (let i = 0; i < numRooms; i++) {
                    let roomW, roomH, roomX, roomY;
                    let attempts = 0;
                    let newRoom;
                    let overlaps;

                    do {
                        roomW = Math.floor(Math.random() * (maxRoomSize - minRoomSize + 1)) + minRoomSize;
                        roomH = Math.floor(Math.random() * (maxRoomSize - minRoomSize + 1)) + minRoomSize;
                        roomX = Math.floor(Math.random() * (mapWidth - roomW - 2)) + 1;
                        roomY = Math.floor(Math.random() * (mapHeight - roomH - 2)) + 1;
                        newRoom = { x: roomX, y: roomY, w: roomW, h: roomH, centerX: roomX + Math.floor(roomW/2), centerY: roomY + Math.floor(roomH/2) };
                        
                        overlaps = false;
                        for(const otherRoom of rooms){
                            if(newRoom.x < otherRoom.x + otherRoom.w + 1 && newRoom.x + newRoom.w + 1 > otherRoom.x &&
                                newRoom.y < otherRoom.y + otherRoom.h + 1 && newRoom.y + newRoom.h + 1 > otherRoom.y){
                                overlaps = true;
                                break;
                            }
                        }
                        attempts++;
                    } while (overlaps && attempts < 50); 

                    if (!overlaps || rooms.length < 1) { 
                        rooms.push(newRoom);
                    } else if (i > 0 && attempts >= 50 && rooms.length > 0) {
                        rooms.push(newRoom);
                    }
                }
                
                if (rooms.length === 0) { 
                    rooms.push({
                        x: Math.floor(mapWidth/2) - 3, y: Math.floor(mapHeight/2) - 3, 
                        w: 7, h: 7, 
                        centerX: Math.floor(mapWidth/2), centerY: Math.floor(mapHeight/2)
                    });
                }

                rooms.forEach(room => { 
                    for (let y = room.y; y < room.y + room.h; y++) {
                        for (let x = room.x; x < room.x + room.w; x++) {
                            if (x > 0 && x < mapWidth -1 && y > 0 && y < mapHeight -1) map[y][x] = 1;
                        }
                    }
                });

                for (let i = 0; i < rooms.length - 1; i++) { 
                    carvePathBetweenRooms(rooms[i], rooms[i+1]);
                }
                if (rooms.length > 1) { 
                    for(let i = 1; i < rooms.length; i++){ 
                            carvePathBetweenRooms(rooms[0], rooms[i]);
                    }
                }

                const playerStartY = rooms[0].centerY;
                const playerStartX = rooms[0].centerX;
                map[playerStartY][playerStartX] = 1; 
                
                const miniBossRoomIndex = rooms.length > 1 ? Math.max(1, Math.floor(rooms.length / 2)) : 0;
                const miniBossY = rooms[miniBossRoomIndex].centerY;
                const miniBossX = rooms[miniBossRoomIndex].centerX; // Corrected: Use centerX
                map[miniBossY][miniBossX] = 1; 

                const bossRoomIndex = rooms.length -1;
                const bossAreaY = rooms[bossRoomIndex].centerY; 
                const bossAreaX = rooms[bossRoomIndex].centerX;
                map[bossAreaY][bossAreaX] = 1; 

                let stairRoom = rooms.length > 1 ? rooms[rooms.length - (currentFloor === maxFloors -1 ? 2 : 1)] : rooms[0]; 
                if (!stairRoom || (stairRoom.centerX === bossAreaX && stairRoom.centerY === bossAreaY && currentFloor === maxFloors)) { 
                    stairRoom = rooms.find(r => r.centerX !== bossAreaX || r.centerY !== bossAreaY) || rooms[0];
                }
                if (!stairRoom) stairRoom = rooms[0]; 

                stairLocation.x = stairRoom.centerX;
                stairLocation.y = stairRoom.centerY;
                map[stairLocation.y][stairLocation.x] = 1; 

                player.tileX = playerStartX; player.tileY = playerStartY;
                player.hasKey = false; player.doorOpened = false;

                monsters = [];
                const duendeCount = 6 + (currentFloor - 1) * 2; 
                const skeletonCount = 3 + Math.floor((currentFloor - 1) * 1.5);
                const wolfCount = 2 + currentFloor; 

                const monsterSpawnLocations = [];
                for(let y=0; y < mapHeight; y++){ for(let x=0; x < mapWidth; x++){
                    if(map[y][x] === 1 && !(x === playerStartX && y === playerStartY)) {
                        monsterSpawnLocations.push({x,y});
                    }
                }}

                hpMultiplier = 1.0; 
                atkMultiplier = 1.0;
                if (selectedDifficulty === 'facil') { hpMultiplier = 0.6; atkMultiplier = 0.7; } 
                else if (selectedDifficulty === 'dificil') { hpMultiplier = 1.5; atkMultiplier = 1.35; }


                const placeMonster = (type, baseHp, baseAtk, spd, xp, dropsKey = false) => {
                    if (monsterSpawnLocations.length === 0) return;
                    let spawnIndex = Math.floor(Math.random() * monsterSpawnLocations.length);
                    let loc = monsterSpawnLocations.splice(spawnIndex, 1)[0];
                    if ((loc.x === miniBossX && loc.y === miniBossY) || (loc.x === bossAreaX && loc.y === bossAreaY) || (loc.x === stairLocation.x && loc.y === stairLocation.y)) {
                        if (monsterSpawnLocations.length > 0) placeMonster(type, baseHp, baseAtk, spd, xp, dropsKey); 
                        return;
                    }
                    const mHp = Math.floor(baseHp * (1+(currentFloor-1)*0.5) * hpMultiplier);
                    const mAtk = Math.floor(baseAtk * (1+(currentFloor-1)*0.3) * atkMultiplier);
                    monsters.push({ type, hp: mHp, maxHp: mHp, atk: mAtk, spd, tileX: loc.x, tileY: loc.y, xp, dropsKey, lastMoveTime: 0, hitFrame: 0, lastAttackTime: 0, isMinion: false }); 
                };
                
                for (let i = 0; i < duendeCount; i++) placeMonster('duende', 20, 15, 1.5, 50);
                for (let i = 0; i < wolfCount; i++) placeMonster('lobo', 25, 20, 2.0, 75);
                for (let i = 0; i < skeletonCount; i++) placeMonster('skeleton', 30, 25, 1, 100);
                
                let miniBossBaseHp = 100; let miniBossBaseAtk = 35;
                let mbHp = Math.floor(miniBossBaseHp * (1+(currentFloor-1)*0.5) * hpMultiplier);
                let mbAtk = Math.floor(miniBossBaseAtk * (1+(currentFloor-1)*0.3) * atkMultiplier);
                monsters.push({ type: 'mini-boss', hp: mbHp, maxHp: mbHp, atk: mbAtk, spd: 1.5, tileX: miniBossX, tileY: miniBossY, xp: 250, dropsKey: true, lastMoveTime: 0, hitFrame: 0, lastAttackTime: 0, isMinion: false }); 
                
                let bossBaseHp = 200; let bossBaseAtk = 50;
                let bHp = Math.floor(bossBaseHp * (1+(currentFloor-1)*0.5) * hpMultiplier);
                let bAtk = Math.floor(bossBaseAtk * (1+(currentFloor-1)*0.3) * atkMultiplier);
                monsters.push({ type: 'boss', hp: bHp, maxHp: bHp, atk: bAtk, spd: 1, tileX: bossAreaX, tileY: bossAreaY, xp: 1000, lastMoveTime: 0, hitFrame: 0, lastAttackTime: 0, isMinion: false }); 
                
                chests = []; spawnChests(monsterSpawnLocations); 
            } 
            loadSprites(); 

            if (monsters.some(m => m.type === 'final-arachnid-boss')) {
                playMusic('boss'); // Play the specific boss music for the final floor
            } else {
                playMusic('dungeon'); // Play a random dungeon track for all other floors
            }
        }
        
        function carvePathBetweenRooms(room1, room2) { 
            let x1 = room1.centerX; let y1 = room1.centerY;
            let x2 = room2.centerX; let y2 = room2.centerY;

            if (Math.random() > 0.5) { 
                for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) {
                    if(map[y1] && map[y1][x] !== undefined) map[y1][x] = 1;
                }
                for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) {
                    if(map[y] && map[y][x2] !== undefined) map[y][x2] = 1;
                }
            } else { 
                for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) {
                    if(map[y] && map[y][x1] !== undefined) map[y][x1] = 1;
                }
                for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) {
                    if(map[y2] && map[y2][x] !== undefined) map[y2][x] = 1;
                }
            }
        }

        function spawnChests(spawnLocations) { 
            const potionTypes = [
                { name: 'Poción de Vida Pequeña', weight: 60 },
                { name: 'Poción de Vida Mediana', weight: 30 },
                { name: 'Poción de Vida Grande', weight: 10 }
            ];

            const getWeightedRandomPotion = () => {
                let totalWeight = 0;
                for (const potion of potionTypes) {
                    totalWeight += potion.weight;
                }

                let randomNum = Math.random() * totalWeight;
                for (const potion of potionTypes) {
                    if (randomNum < potion.weight) {
                        return gearList.find(g => g.name === potion.name);
                    }
                    randomNum -= potion.weight;
                }
                return gearList.find(g => g.name === 'Poción de Vida Pequeña'); 
            };

            let availableSpawnPoints = [...spawnLocations]; 
            
            let numChestsToSpawn;
            if (selectedDifficulty === 'facil') {
                numChestsToSpawn = Math.floor(Math.random() * 2) + 2; // 2-3 chests
            } else if (selectedDifficulty === 'medio') {
                numChestsToSpawn = Math.floor(Math.random() * 3) + 1; // 1-3 chests
            } else if (selectedDifficulty === 'dificil') {
                numChestsToSpawn = Math.floor(Math.random() * 3); // 0-2 chests
            } else {
                numChestsToSpawn = Math.floor(Math.random() * 3) + 1; // Default to medium
            }

            for (let i = 0; i < numChestsToSpawn; i++) { 
                if (availableSpawnPoints.length === 0) break;

                let spawnIndex = Math.floor(Math.random() * availableSpawnPoints.length);
                let loc = availableSpawnPoints.splice(spawnIndex, 1)[0]; 
                
                if ((loc.x === player.tileX && loc.y === player.tileY) ||
                    (loc.x === stairLocation.x && loc.y === stairLocation.y) ||
                    monsters.some(m => m.tileX === loc.x && m.tileY === loc.y)) {
                    i--; 
                    continue;
                }

                const randomLoot = getWeightedRandomPotion(); 
                
                chests.push({ tileX: loc.x, tileY: loc.y, gear: randomLoot });
                map[loc.y][loc.x] = 2; 
            }
        }
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        let lastMoveTime = 0;
        let lastAttackTime = 0;
        const monsterAttackInterval = 1000; 
        
        let selectedIndex = 0; 
        let selectedSkillIndex = 0; 
        let selectedEquipmentSlotIndex = 0; 
        let gameOver = false;
        let walkFrame = 0; 
        let keys = {
            ArrowLeft: false, ArrowRight: false, ArrowUp: false, ArrowDown: false,
            KeyA: false, KeyD: false, KeyW: false, KeyS: false,
            Space: false, KeyE: false, KeyI: false, KeyY: false, KeyR: false, KeyO: false,
            Digit1: false, Digit2: false, Digit3: false, Digit4: false, Digit5: false, Digit6: false,
            Digit7: false, Digit8: false, Digit9: false, Digit0: false 
        };
        

        const difficultyScreen = document.getElementById('difficultyScreen');
        const gameCanvas = document.getElementById('gameCanvas');
        const difficultyTitleElement = document.getElementById('difficultyTitle');
        const lastScoreDisplayElement = document.getElementById('lastScoreDisplay');
        const levelInputElement = document.getElementById('levelInput'); 
        const goToFloorButton = document.getElementById('btnGoToFloor');
        const messageBox = document.getElementById('messageBox'); 
        const equipmentMenu = document.getElementById('equipmentMenu'); 
        const btnEquipment = document.getElementById('btnEquipment'); 
        const equippedSlotsDiv = document.getElementById('equippedSlots'); 
        const equipmentMenuInstructions = document.getElementById('equipmentMenuInstructions'); 

        const btnSaveEquipment = document.getElementById('btnSaveEquipment');
        const btnReturnToDifficulty = document.getElementById('btnReturnToDifficulty');

        // New audio elements for dungeon tracks
        const dungeonTracks = [
            document.getElementById('audioDungeon1'),
            document.getElementById('audioDungeon2'),
            document.getElementById('audioDungeon3'),
            document.getElementById('audioDungeon4'),
            document.getElementById('audioDungeon5'),
            document.getElementById('audioDungeon6'),
            document.getElementById('audioDungeon7'),
            document.getElementById('audioDungeon8'),
            document.getElementById('audioDungeon9'),
            document.getElementById('audioDungeon10')
        ];
        let currentDungeonTrackIndex = 0; // To cycle through dungeon tracks

        // New audio elements for boss and equipment
        const audioBoss = document.getElementById('audioBoss');
        const audioEquipmentOpen = document.getElementById('audioEquipmentOpen');

        let currentAudioTrack = null;

        function playMusic(track) {
            let nextTrackElement = null;

            // Pause current track if it's playing
            if (currentAudioTrack) {
                currentAudioTrack.pause();
                currentAudioTrack.currentTime = 0; // Reset to beginning
            }

            switch (track) {
                case 'dungeon':
                    // Play a random dungeon track
                    currentDungeonTrackIndex = Math.floor(Math.random() * dungeonTracks.length);
                    nextTrackElement = dungeonTracks[currentDungeonTrackIndex];
                    break;
                case 'boss':
                    nextTrackElement = audioBoss;
                    break;
                case 'equipmentOpen': // New case for equipment open sound
                    nextTrackElement = audioEquipmentOpen;
                    break;
                default:
                    nextTrackElement = null;
            }

            currentAudioTrack = nextTrackElement;
            if (currentAudioTrack) {
                // For one-shot sounds, reset and play
                if (track === 'floorUp' || track === 'criticalHit' || track === 'chestOpen' || track === 'equipmentOpen' || track === 'gameOver' || track === 'victory') {
                    currentAudioTrack.currentTime = 0; 
                }
                currentAudioTrack.play().catch(e => console.error("Error playing audio:", e));
            }
        }


        // Custom message box for alerts
        function showMessage(message) {
            messageBox.textContent = message;
            messageBox.style.display = 'block';
            setTimeout(() => {
                messageBox.style.display = 'none';
            }, 2000); 
        }


        document.getElementById('btnFacil').addEventListener('click', () => setDifficultyAndStart('facil'));
        document.getElementById('btnMedio').addEventListener('click', () => setDifficultyAndStart('medio'));
        document.getElementById('btnDificil').addEventListener('click', () => setDifficultyAndStart('dificil'));
        goToFloorButton.addEventListener('click', () => {
            const baseLevel = parseInt(levelInputElement.value); 
            if (baseLevel >= 1) {
                if (!gameStarted) { 
                    setDifficultyAndStart(selectedDifficulty, 1, baseLevel); 
                } else { 
                    player.level = baseLevel;
                    player.baseAtk = 5 + Math.floor((player.level - 1) * 1.5);
                    player.baseDef = 3 + (player.level - 1);
                    player.maxHp = 100 + (player.level - 1) * 20;
                    player.hp = player.maxHp; 
                    updateStats();
                    showMessage(`Nivel del jugador ajustado a ${player.level}.`);
                }
            } else {
                showMessage(`Por favor ingresa un nivel base de 1 o superior.`);
            }
        });

        // Event listener for the new "Equipo" button - accessible before game start
        btnEquipment.addEventListener('click', () => {
            toggleEquipmentMenu();
        });

        btnSaveEquipment.addEventListener('click', () => {
            savePlayerDataToLocalStorage();
            showMessage("¡Equipo guardado!");
        });

        btnReturnToDifficulty.addEventListener('click', () => {
            toggleEquipmentMenu(); 
        });

        // Add a click listener to the difficulty screen to initiate music playback
        difficultyScreen.addEventListener('click', () => {
            // Only play menu music if it's not already playing and the game hasn't started
            if (!gameStarted && currentAudioTrack !== audioMenu) {
                // playMusic('menu'); // This can be uncommented if menu music is desired
            }
        });


        // Function to save player data to localStorage
        function savePlayerDataToLocalStorage() {
            const dataToSave = {
                hp: player.hp,
                maxHp: player.maxHp,
                atk: player.atk,
                def: player.def,
                spd: player.spd,
                xp: player.xp,
                level: player.level,
                skillPoints: player.skillPoints,
                inventory: player.inventory.map(item => ({ name: item.name, type: item.type })), 
                equipped: {}, 
                permanentlyLearnedSkills: player.permanentlyLearnedSkills,
                gold: player.gold,
                enemiesDefeatedThisRun: player.enemiesDefeatedThisRun,
                baseSpd: player.baseSpd,
                baseAtk: player.baseAtk,
                baseDef: player.baseDef,
                criticalChanceBonus: player.criticalChanceBonus,
                stealthActive: player.stealthActive, 
                stealthStatMultiplier: player.stealthStatMultiplier 
            };
            for (const slot in player.equipped) {
                if (player.equipped[slot]) {
                    if (slot.startsWith('habilidad')) {
                        dataToSave.equipped[slot] = player.equipped[slot]; 
                    } else {
                        dataToSave.equipped[slot] = { name: player.equipped[slot].name, type: player.equipped[slot].type };
                    }
                } else {
                    dataToSave.equipped[slot] = null;
                }
            }
            localStorage.setItem('dungeonCrawlerPlayerData', JSON.stringify(dataToSave));
        }

        // Function to load player data from localStorage
        function loadPlayerDataFromLocalStorage() {
            const storedData = localStorage.getItem('dungeonCrawlerPlayerData');
            if (storedData) {
                const loadedPlayer = JSON.parse(storedData);
                Object.assign(player, loadedPlayer);
                
                // Re-map equipped items to actual gearList objects, ensuring all properties are present
                for (const slot in loadedPlayer.equipped) {
                    if (slot.startsWith('habilidad')) {
                        player.equipped[slot] = loadedPlayer.equipped[slot]; 
                    } else if (loadedPlayer.equipped[slot]) {
                        const fullItem = gearList.find(g => g.name === loadedPlayer.equipped[slot].name);
                        player.equipped[slot] = fullItem || null; 
                    } else {
                        player.equipped[slot] = null;
                    }
                }

                // Re-map inventory items to actual gearList objects
                player.inventory = loadedPlayer.inventory
                    .map(itemData => gearList.find(g => g.name === itemData.name))
                    .filter(item => item !== undefined); 
                
            } else {
                // Initial starting gear if no saved data exists: Add ALL equipment items to inventory
                player.inventory = gearList.filter(item => item.type !== 'potion'); 
                
                // Set initial equipped items to the first item of each type if available
                player.equipped.weapon = gearList.find(g => g.name === 'Daga de Poder') || null;
                player.equipped.helmet = gearList.find(g => g.name === 'Casco de Hierro') || null;
                player.equipped.armor = gearList.find(g => g.name === 'Armadura de Hierro') || null;
                player.equipped.gloves = gearList.find(g => g.name === 'Guantes de Hierro') || null;
                player.equipped.boots = gearList.find(g => g.name === 'Botas de Hierro') || null;
                
                // Initial permanently learned skills (all skills are "learned" for equipment selection)
                player.permanentlyLearnedSkills = skills.map(s => s.name);
                // Set an initial equipped habilidad
                player.equipped.habilidad1 = 'Sigilo'; 
                player.equipped.habilidad2 = null;
                player.equipped.habilidad3 = null;
            }
        }

        function setDifficultyAndStart(difficulty, startFloor = 1, baseLevel = 1) { 
            selectedDifficulty = difficulty;
            hpMultiplier = 1.0; 
            atkMultiplier = 1.0;
            if (selectedDifficulty === 'facil') { hpMultiplier = 0.6; atkMultiplier = 0.7; } 
            else if (selectedDifficulty === 'dificil') { hpMultiplier = 1.5; atkMultiplier = 1.35; }

            difficultyScreen.style.display = 'none';
            gameCanvas.style.display = 'block'; 
            minimapCanvas.style.display = 'block'; 
            equipmentMenu.style.display = 'none'; 
            
            currentFloor = startFloor; 

            // Re-initialize player stats, but load equipped gear and learned skills
            let tempPlayer = { 
                tileX: 1, tileY: 1, hp: 100, maxHp: 100, 
                atk: 5 + Math.floor((baseLevel - 1) * 1.5), 
                def: 3 + (baseLevel - 1), 
                spd: 4, 
                xp: 0, level: baseLevel, skillPoints: 0, 
                inventory: [], 
                equipped: { 
                    helmet: null, armor: null, gloves: null, boots: null, weapon: null, 
                    habilidad1: null, habilidad2: null, habilidad3: null 
                },
                unlockedSkills: [], 
                permanentlyLearnedSkills: [], 
                hasKey: false, facingDirection: 'right', 
                hitFrame: 0, doorOpened: false, lastHitTime:0, invulnerabilityTime:500,
                isAttacking: false, attackAnimFrame: 0, attackAnimDuration: 7, attackLungeDistance: tileSize / 4,
                skillUsageThisFloor: {},
                enemiesDefeatedThisRun: 0,
                gold: 0,
                isSlowed: false, slowEndTime: 0,
                potionsBoughtTotal: 0,
                isStealthed: false, stealthEndTime: 0,
                stealthActive: false, 
                stealthStatMultiplier: 1.0, 
                nextHitCritical: false,
                isInvincible: false, invincibleEndTime: 0,
                isSpeedBoosted: false, speedBoostEndTime: 0,
                luckBoostEndTime: 0,
                soulExtractionActive: false,
                furyActive: false,
                baseSpd: 4, 
                baseAtk: 5 + Math.floor((baseLevel - 1) * 1.5), 
                baseDef: 3 + (baseLevel - 1), 
                criticalChanceBonus: 0,
                celestialBookCritCounter: 0,
                hasMiniShield: false,
                miniShieldHP: 0,
                miniShieldMaxHP: 0,
                miniShieldCooldownEnd: 0,
                darkRayEnemiesDefeated: 0
            };
            // Preserve equipped items and learned skills from the pre-game setup
            for (const slot in player.equipped) {
                if (slot.startsWith('habilidad')) {
                    tempPlayer.equipped[slot] = player.equipped[slot];
                } else {
                    tempPlayer.equipped[slot] = player.equipped[slot] ? { ...player.equipped[slot] } : null;
                }
            }
            tempPlayer.inventory = player.inventory.map(item => ({ ...item })); 
            tempPlayer.permanentlyLearnedSkills = [...player.permanentlyLearnedSkills]; 
            tempPlayer.skillPoints = player.skillPoints; 

            player = tempPlayer; 
            player.maxHp = 100 + (player.level - 1) * 20; 
            player.hp = player.maxHp; 

            projectiles = [];
            damageTexts = [];
            criticalHitEffects = [];
            skillCooldowns = {};
            skills.forEach(skill => {
                if (skill.cooldown > 0) {
                    skillCooldowns[skill.name] = 0; 
                }
            });

            stairLocation.active = false;
            monsters = [];
            chests = [];

            gameStarted = true;
            gameOver = false; 
            
            generateFloor(); 
            updateStats(); 
            loadSprites(); 
            const minimapTileSize = 5; 
            minimapCanvas.width = mapWidth * minimapTileSize;
            minimapCanvas.height = mapHeight * minimapTileSize;
            
            requestAnimationFrame(gameLoop);
        }


        document.addEventListener('keydown', (e) => {
            // Allow navigation in menus even if game hasn't started
            if (isInventoryOpen || isSkillMenuOpen || isEquipmentOpen) {
                if (e.code === 'KeyI' || e.code === 'KeyY' || e.code === 'KeyO' || e.code === 'Escape' ||
                    e.code === 'ArrowUp' || e.code === 'ArrowDown' || e.code === 'ArrowLeft' || e.code === 'ArrowRight' ||
                    e.code === 'Enter' || e.code === 'KeyV') {
                    e.preventDefault(); 
                    if (isInventoryOpen) handleInventoryInput(e);
                    else if (isSkillMenuOpen) handleSkillInput(e);
                    else if (isEquipmentOpen) handleEquipmentInput(e);
                    return;
                }
            }

            // Game over state handling
            if (gameOver) {
                if (e.code === 'KeyR') keys.KeyR = true; 
                e.preventDefault(); 
                return;
            }

            // In-game menu toggles
            if (e.code === 'KeyI') { toggleInventory(); e.preventDefault(); return; }
            if (e.code === 'KeyY') { toggleSkillMenu(); e.preventDefault(); return; }

            // In-game actions (movement, attack, skill activation)
            if (!isInventoryOpen && !isSkillMenuOpen && !isEquipmentOpen) {
                // Allow activation of equipped skills using Digits 1, 2, 3
                if (e.code === 'Digit1' && player.equipped.habilidad1) {
                    activateSkill(player.equipped.habilidad1);
                    e.preventDefault();
                    return;
                } else if (e.code === 'Digit2' && player.equipped.habilidad2) {
                    activateSkill(player.equipped.habilidad2);
                    e.preventDefault();
                    return;
                } else if (e.code === 'Digit3' && player.equipped.habilidad3) {
                    activateSkill(player.equipped.habilidad3);
                    e.preventDefault();
                    return;
                }

                if (keys.hasOwnProperty(e.code)) {
                    keys[e.code] = true;
                    if (e.code === 'Space' || e.code.startsWith('Arrow') || 
                        ['KeyA', 'KeyD', 'KeyW', 'KeyS'].includes(e.code)) {
                        e.preventDefault();
                    }
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.code)) {
                if (e.code === 'KeyR' && gameOver) { 
                } else {
                    keys[e.code] = false;
                }
            }
        });

        // --- Funciones de Dibujo ---
        function drawFloor(x, y) { if(loadedImages.floor && loadedImages.floor.complete) ctx.drawImage(loadedImages.floor, 0,0,64,64, x, y, tileSize, tileSize); else { ctx.fillStyle = '#aaa'; ctx.fillRect(x,y,tileSize,tileSize);}}
        function drawWall(x, y) { if(loadedImages.wall && loadedImages.wall.complete) ctx.drawImage(loadedImages.wall, 0,0,64,64, x, y, tileSize, tileSize); else { ctx.fillStyle = '#555'; ctx.fillRect(x,y,tileSize,tileSize);}}
        function drawChest(x, y) { if(loadedImages.chest && loadedImages.chest.complete) ctx.drawImage(loadedImages.chest, 0,0,64,64, x, y, tileSize, tileSize); else { ctx.fillStyle = '#8B4513'; ctx.fillRect(x,y,tileSize,tileSize);}}
        function drawStairs(x,y) { if(loadedImages.stairs && loadedImages.stairs.complete) ctx.drawImage(loadedImages.stairs, 0,0,64,64, x, y, tileSize, tileSize); else { ctx.fillStyle = '#704214'; ctx.fillRect(x,y,tileSize,tileSize);}}


        function drawPlayer(x, y) {
            let drawX = x;
            let drawY = y;

            if (player.isAttacking) {
                const progress = player.attackAnimFrame / player.attackAnimDuration; 
                let lunge = 0;
                if (progress < 0.5) { 
                    lunge = player.attackLungeDistance * (progress / 0.5);
                } else { 
                    lunge = player.attackLungeDistance * ((1 - progress) / 0.5);
                }

                if (player.facingDirection === 'right') drawX += lunge;
                else if (player.facingDirection === 'left') drawX -= lunge;
                else if (player.facingDirection === 'up') drawY -= lunge;
                else if (player.facingDirection === 'down') drawY += lunge;
            }


            if (loadedImages.player && loadedImages.player.complete) {
                ctx.drawImage(loadedImages.player, 0,0,64,64, drawX, drawY, tileSize, tileSize);
            } else { 
                ctx.fillStyle = 'blue'; ctx.fillRect(drawX, drawY, tileSize, tileSize);
            }

            if (player.hitFrame > 0) { 
                ctx.save();
                ctx.globalAlpha = 0.5 + (player.hitFrame / 10) * 0.3; 
                ctx.fillStyle = 'red'; 
                ctx.fillRect(drawX, drawY, tileSize, tileSize); 
                ctx.restore();
                player.hitFrame--; 
            }
            const currentTime = Date.now();
            if (currentTime - player.lastHitTime < player.invulnerabilityTime) { 
                ctx.save();
                ctx.globalAlpha = 0.3 + Math.sin(currentTime / 100) * 0.2; 
                ctx.fillStyle = 'rgba(100, 100, 255, 0.7)'; 
                ctx.beginPath();
                ctx.arc(drawX + tileSize/2, drawY + tileSize/2, tileSize/2 + 3, 0, Math.PI*2);
                ctx.fill();
                ctx.restore();
            }
            if (player.isSlowed && currentTime < player.slowEndTime) {
                ctx.fillStyle = 'rgba(0, 100, 255, 0.3)'; 
                ctx.fillRect(drawX, drawY, tileSize, tileSize);
            }
            if (player.isInvincible && currentTime < player.invincibleEndTime) {
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)'; 
                ctx.fillRect(drawX, drawY, tileSize, tileSize);
            }
            if (player.stealthActive && currentTime < player.stealthEndTime) { 
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; 
                ctx.fillRect(drawX, drawY, tileSize, tileSize);
            }

            // Draw mini-shield if active
            if (player.hasMiniShield && player.miniShieldHP > 0) {
                ctx.save();
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)'; 
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(drawX + tileSize / 2, drawY + tileSize / 2, tileSize / 2 + 5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = 'rgba(0, 255, 255, 0.2)'; 
                ctx.fill();

                // Draw mini-shield HP bar
                const shieldHealthPercent = player.miniShieldHP / player.miniShieldMaxHP;
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(drawX + 5, drawY - 15, tileSize - 10, 5);
                ctx.fillStyle = shieldHealthPercent > 0.5 ? 'rgba(0,255,255,0.7)' : shieldHealthPercent > 0.25 ? 'rgba(255,255,0,0.7)' : 'rgba(255,0,0,0.7)';
                ctx.fillRect(drawX + 5, drawY - 15, (tileSize - 10) * shieldHealthPercent, 5);

                ctx.restore();
            }


            const healthPercent = player.hp / player.maxHp;
            ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(drawX+5, drawY-10, tileSize-10, 5);
            ctx.fillStyle = healthPercent > 0.5 ? 'rgba(0,255,0,0.7)' : healthPercent > 0.25 ? 'rgba(255,255,0,0.7)' : 'rgba(255,0,0,0.7)';
            ctx.fillRect(drawX+5, drawY-10, (tileSize-10)*healthPercent, 5);
        }

        function drawMonster(m, screenX, screenY) {
            let monsterImage;
            if (m.type === 'duende') monsterImage = loadedImages.duende; 
            else if (m.type === 'lobo') monsterImage = loadedImages.lobo;
            else if (m.type === 'skeleton') monsterImage = loadedImages.skeleton;
            else if (m.type === 'mini-boss') monsterImage = loadedImages.miniBoss;
            else if (m.type === 'boss') monsterImage = loadedImages.boss;
            else if (m.type === 'final-arachnid-boss') monsterImage = loadedImages.finalBoss; 
            else if (m.type === 'spiderling') monsterImage = loadedImages.spiderling;
            else if (m.type === 'minion') { 
                monsterImage = loadedImages.minion; 
            }


            if (monsterImage && monsterImage.complete) {
                let drawWidth = tileSize * (m.width || 1);
                let drawHeight = tileSize * (m.height || 1);
                ctx.drawImage(monsterImage, 0,0,64,64, screenX, screenY, drawWidth, drawHeight);
            } else { 
                ctx.fillStyle = m.type === 'duende' ? '#5C6B00' : (m.type === 'lobo' ? '#8C0000' : (m.type === 'final-arachnid-boss' ? '#3A1E00' : (m.type === 'spiderling' ? '#4A2A05' : 'gray'))); 
                ctx.fillRect(screenX, screenY, tileSize * (m.width || 1), tileSize * (m.height || 1));
            }
            if (m.hitFrame > 0) { ctx.fillStyle = 'rgba(255,0,0,0.5)'; ctx.fillRect(screenX, screenY, tileSize * (m.width || 1), tileSize * (m.height || 1)); }
            if (m.isFrozen && Date.now() < m.frozenEndTime) {
                ctx.fillStyle = 'rgba(0, 191, 255, 0.3)'; 
                ctx.fillRect(screenX, screenY, tileSize * (m.width || 1), tileSize * (m.height || 1));
            }
            if (m.isWeakened && Date.now() < m.weaknessEndTime) {
                ctx.fillStyle = 'rgba(128, 0, 128, 0.3)'; 
                ctx.fillRect(screenX, screenY, tileSize * (m.width || 1), tileSize * (m.height || 1));
            }
            if (m.isBleeding && Date.now() < m.bleedingEndTime) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)'; 
                ctx.fillRect(screenX, screenY, tileSize * (m.width || 1), tileSize * (m.height || 1));
            }
            if (m.isAttackSlowed && Date.now() < m.attackSlowEndTime) {
                ctx.fillStyle = 'rgba(135, 206, 235, 0.3)'; 
                ctx.fillRect(screenX, screenY, tileSize * (m.width || 1), tileSize * (m.height || 1));
            }

            const healthPercentMonster = m.hp / m.maxHp; 
            ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(screenX+5, screenY-10, tileSize-10, 5);
            ctx.fillStyle = healthPercentMonster > 0.5 ? 'rgba(0,255,0,0.7)' : healthPercentMonster > 0.25 ? 'rgba(255,255,0,0.7)' : 'rgba(255,0,0,0.7)';
            ctx.fillRect(screenX+5, screenY-10, (tileSize-10)*healthPercentMonster, 5);
        }
        
        function drawProjectiles(offsetX, offsetY) {
            projectiles.forEach(proj => {
                const screenX = proj.x * tileSize - offsetX;
                const screenY = proj.y * tileSize - offsetY;
                
                ctx.save();
                ctx.translate(screenX + tileSize / 2, screenY + tileSize / 2); 

                let rotationAngle = 0;
                if (proj.type === 'arrow' || proj.type === 'web' || proj.type === 'dark_ray' || proj.type === 'celestial_ray') { 
                    rotationAngle = Math.atan2(proj.dy, proj.dx);
                }
                ctx.rotate(rotationAngle);

                if (proj.type === 'fireball') {
                    ctx.fillStyle = 'rgba(255, 50, 0, 0.8)'; ctx.beginPath();
                    ctx.arc(0, 0, tileSize/3, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = 'rgba(255, 165, 0, 0.6)';
                    for(let i=0; i<3; i++) { 
                        const angle = Math.random() * Math.PI * 2; const dist = Math.random() * tileSize/3; 
                        ctx.beginPath();
                        ctx.arc(Math.cos(angle)*dist, Math.sin(angle)*dist, tileSize/8, 0, Math.PI*2); 
                        ctx.fill();
                    }
                } else if (proj.type === 'web') {
                    const animationProgress = proj.distanceTraveled / proj.maxRangeTiles;
                    const currentRadius = animationProgress * tileSize * 0.7; 
                    const alpha = 1 - animationProgress; 

                    ctx.fillStyle = `rgba(200, 200, 200, ${alpha * 0.7})`; 
                    ctx.beginPath();
                    ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = `rgba(220, 220, 220, ${alpha})`;
                    ctx.lineWidth = 1 + animationProgress * 2; 
                    for(let i=0; i< 5; i++){
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(i * Math.PI * 2 / 5) * currentRadius, Math.sin(i * Math.PI * 2 / 5) * currentRadius);
                        ctx.stroke();
                    }
                } else if (proj.type === 'arrow') {
                    ctx.fillStyle = '#8B4513'; 
                    ctx.fillRect(-2, -10, 4, 20); 
                    ctx.beginPath(); 
                    ctx.moveTo(0, -10);
                    ctx.lineTo(-5, -5);
                    ctx.lineTo(5, -5);
                    ctx.closePath();
                    ctx.fill();
                } else if (proj.type === 'dark_ray') {
                    ctx.fillStyle = 'rgba(138, 43, 226, 0.8)'; 
                    ctx.fillRect(-5, -5, 10, 10); 
                    const glow = ctx.createRadialGradient(0, 0, 2, 0, 0, 15);
                    glow.addColorStop(0, 'rgba(138, 43, 226, 0.8)');
                    glow.addColorStop(1, 'rgba(138, 43, 226, 0)');
                    ctx.fillStyle = glow;
                    ctx.beginPath();
                    ctx.arc(0, 0, 15, 0, Math.PI * 2);
                    ctx.fill();
                } else if (proj.type === 'celestial_ray') { 
                    // Draw a more distinct ray
                    const rayLength = tileSize * 1.5; // Make the ray longer
                    const rayWidth = tileSize * 0.15; // Make it thinner
                    const glowRadius = tileSize * 0.8; // Larger glow

                    // Main ray body
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.9)'; // Bright yellow
                    ctx.fillRect(-rayWidth / 2, -rayLength / 2, rayWidth, rayLength);

                    // Add a strong radial glow
                    const glow = ctx.createRadialGradient(0, 0, rayWidth / 4, 0, 0, glowRadius);
                    glow.addColorStop(0, 'rgba(255, 255, 100, 0.8)'); // Brighter core
                    glow.addColorStop(0.5, 'rgba(255, 255, 0, 0.4)'); // Yellow glow
                    glow.addColorStop(1, 'rgba(255, 255, 0, 0)'); // Fades out
                    ctx.fillStyle = glow;
                    ctx.beginPath();
                    ctx.arc(0, 0, glowRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Add some sparkling particles
                    for (let i = 0; i < 3; i++) {
                        const sparkX = (Math.random() - 0.5) * rayWidth * 2;
                        const sparkY = (Math.random() - 0.5) * rayLength * 2;
                        const sparkSize = Math.random() * 3 + 1;
                        ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + Math.random() * 0.5})`;
                        ctx.beginPath();
                        ctx.arc(sparkX, sparkY, sparkSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                ctx.restore(); 
            });
        }

        let damageTexts = [];
        let screenShake = 0;
        let criticalHitEffects = [];
        let warMaceShockwave = null; 

        function drawDamageTexts() {
            damageTexts = damageTexts.filter(text => {
                text.y += text.velY; text.life--;
                const alpha = Math.min(1, text.life / 20);
                ctx.font = `bold ${text.size}px Arial`; ctx.textAlign = 'center';
                ctx.strokeStyle = `rgba(0,0,0,${alpha})`; ctx.lineWidth = 3; 
                ctx.strokeText(text.text, text.x, text.y);
                if (text.color.startsWith('#ff0000') || text.color.startsWith('rgba(255,0,0') || text.color.startsWith('#00ff00') || text.color.startsWith('rgba(0,255,0')) { 
                    ctx.shadowColor = text.color.startsWith('#00ff00') || text.color.startsWith('rgba(0,255,0') ? `rgba(0,255,0,${alpha*0.7})` : `rgba(255,0,0,${alpha*0.7})`; 
                    ctx.shadowBlur = 7; 
                }
                
                let finalColor = text.color;
                if (text.color.startsWith('#')) {
                    let r = parseInt(text.color.slice(1,3), 16), g = parseInt(text.color.slice(3,5), 16), b = parseInt(text.color.slice(5,7), 16);
                    finalColor = `rgba(${r},${g},${b},${alpha})`;
                } else if (text.color.startsWith('rgb(')) { 
                    finalColor = text.color.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
                } else if (text.color.startsWith('rgba(')) { 
                    finalColor = text.color.replace(/,\s*\d?\.?\d*\)/, `, ${alpha})`);
                }
                ctx.fillStyle = finalColor;

                ctx.fillText(text.text, text.x, text.y);
                ctx.shadowBlur = 0; 
                ctx.shadowColor = 'transparent';
                return text.life > 0;
            });
        }

        function drawCriticalHitEffects(offsetX, offsetY) {
            criticalHitEffects = criticalHitEffects.filter(effect => {
                effect.life--;
                const monsterScreenX = effect.monster.tileX * tileSize - offsetX;
                const monsterScreenY = effect.monster.tileY * tileSize - offsetY;
                ctx.save();
                ctx.strokeStyle = `rgba(255,0,0, ${effect.life/15})`; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(monsterScreenX + tileSize/2, monsterScreenY + tileSize/2);
                const particleX = monsterScreenX + tileSize/2 + (Math.random()-0.5)*20;
                const particleY = monsterScreenY + tileSize/2 + (Math.random()-0.5)*10;
                ctx.lineTo(particleX, particleY); ctx.stroke();
                const gradient = ctx.createRadialGradient(monsterScreenX+tileSize/2, monsterScreenY+tileSize/2,0, monsterScreenX+tileSize/2, monsterScreenY+tileSize/2, effect.size/3);
                gradient.addColorStop(0, `rgba(255,0,0,${effect.life/30})`); gradient.addColorStop(1, 'rgba(255,0,0,0)');
                ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(monsterScreenX+tileSize/2, monsterScreenY+tileSize/2,0,0,Math.PI*2); ctx.fill();
                ctx.restore();
                return effect.life > 0;
            });
        }

        function drawWarMaceShockwave(offsetX, offsetY) {
            if (!warMaceShockwave) return;

            warMaceShockwave.life--;
            if (warMaceShockwave.life <= 0) {
                warMaceShockwave = null;
                return;
            }

            const centerX = warMaceShockwave.x * tileSize - offsetX + tileSize / 2;
            const centerY = warMaceShockwave.y * tileSize - offsetY + tileSize / 2;
            const radius = (1 - warMaceShockwave.life / 15) * tileSize * 1.5; 
            const alpha = warMaceShockwave.life / 15;

            ctx.save();
            ctx.strokeStyle = `rgba(255, 255, 0, ${alpha})`; 
            ctx.lineWidth = 5 * alpha; 
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
        
        function drawMap() {
            const offsetX = Math.max(0, Math.min(player.tileX * tileSize - canvas.width / 2 + tileSize / 2, mapWidth * tileSize - canvas.width));
            const offsetY = Math.max(0, Math.min(player.tileY * tileSize - canvas.height / 2 + tileSize / 2, mapHeight * tileSize - canvas.height));
            const startX = Math.floor(offsetX / tileSize);
            const endX = Math.min(mapWidth - 1, Math.ceil((offsetX + canvas.width) / tileSize));
            const startY = Math.floor(offsetY / tileSize);
            const endY = Math.min(mapHeight - 1, Math.ceil((offsetY + canvas.height) / tileSize));

            let shakeOffsetX = 0, shakeOffsetY = 0;
            if (screenShake > 0) {
                shakeOffsetX = (Math.random() - 0.5) * screenShake * 2; 
                shakeOffsetY = (Math.random() - 0.5) * screenShake * 2;
                screenShake--;
            }
            ctx.fillStyle = '#2a1f15'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save(); ctx.translate(shakeOffsetX, shakeOffsetY);

            for (let y = startY; y <= endY; y++) {
                for (let x = startX; x <= endX; x++) {
                    const screenX = x * tileSize - offsetX; const screenY = y * tileSize - offsetY;
                    if (map[y] && map[y][x] !== undefined) { 
                        if (map[y][x] === 0) drawWall(screenX, screenY);
                        else if (map[y][x] === 1) drawFloor(screenX, screenY);
                        else if (map[y][x] === 2) { drawFloor(screenX, screenY); drawChest(screenX, screenY); }
                        else if (map[y][x] === stairLocation.type && stairLocation.active) { 
                            drawFloor(screenX, screenY); 
                            drawStairs(screenX, screenY);
                        }
                        else { 
                            drawFloor(screenX, screenY);
                        }
                    } else { 
                        drawFloor(screenX, screenY);
                    }
                }
            }
            monsters.forEach(m => {
                const screenX = m.tileX * tileSize - offsetX; const screenY = m.tileY * tileSize - offsetY;
                drawMonster(m, screenX, screenY);
            });
            const playerScreenX = player.tileX * tileSize - offsetX;
            const playerScreenY = player.tileY * tileSize - offsetY;
            drawPlayer(playerScreenX, playerScreenY); 
            drawProjectiles(offsetX, offsetY);
            drawCriticalHitEffects(offsetX, offsetY); 
            drawDamageTexts(); 
            drawWarMaceShockwave(offsetX, offsetY); 

            ctx.restore(); 
            drawHUD(); 
            drawMinimap(); 

            if (gameOver) {
                ctx.fillStyle = 'rgba(0,0,0,0.7)'; ctx.fillRect(0,0,canvas.width,canvas.height);
                ctx.textAlign = 'center';
                
                if (player.hp <= 0) { 
                    ctx.fillStyle = 'white';
                    ctx.font = '30px Arial';
                    ctx.fillText(finalOutcomeMessage, canvas.width/2, canvas.height/2 - 60);
                } else { 
                    ctx.fillStyle = '#00BFFF'; 
                    ctx.font = '26px Arial'; 
                    ctx.fillText("Haz Completado la Mazmorra", canvas.width/2, canvas.height/2 - 70);
                    ctx.fillText("Haz superado la clase E", canvas.width/2, canvas.height/2 - 40);
                }

                ctx.fillStyle = 'white'; 
                ctx.font = '24px Arial';
                ctx.fillText(`Puntuación: ${lastGameScore}`, canvas.width/2, canvas.height/2);
                ctx.fillText(`Enemigos Derrotados: ${lastEnemiesDefeated}`, canvas.width/2, canvas.height/2 + 30);
                ctx.font = '20px Arial';
                ctx.fillText('Presiona R para volver al menú', canvas.width/2, canvas.height/2 + 70);
            }
        }

        function drawMinimap() {
            const minimapTileSize = 5; 
            minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);

            for (let y = 0; y < mapHeight; y++) {
                for (let x = 0; x < mapWidth; x++) {
                    const miniX = x * minimapTileSize;
                    const miniY = y * minimapTileSize;

                    if (map[y][x] === 0) { 
                        minimapCtx.fillStyle = '#333';
                    } else if (map[y][x] === 1) { 
                        minimapCtx.fillStyle = '#888';
                    } else if (map[y][x] === 2) { 
                        minimapCtx.fillStyle = '#FFD700'; 
                    } else if (map[y][x] === stairLocation.type && stairLocation.active) { 
                        minimapCtx.fillStyle = '#00FFFF'; 
                    }
                    minimapCtx.fillRect(miniX, miniY, minimapTileSize, minimapTileSize);
                }
            }

            minimapCtx.fillStyle = 'blue';
            minimapCtx.fillRect(player.tileX * minimapTileSize, player.tileY * minimapTileSize, minimapTileSize, minimapTileSize);

            monsters.forEach(m => { 
                if (m.isMinion) { 
                    minimapCtx.fillStyle = 'cyan';
                } else {
                    minimapCtx.fillStyle = 'red';
                }
                minimapCtx.fillRect(m.tileX * minimapTileSize, m.tileY * minimapTileSize, minimapTileSize * (m.width || 1), minimapTileSize * (m.height || 1));
            });
        }


        function drawHUD() {
            ctx.fillStyle = 'rgba(244,228,188,0.7)'; ctx.fillRect(canvas.width-170, 10, 160, 210); /* Adjusted height */
            ctx.strokeStyle = '#8B4513'; ctx.lineWidth = 2; ctx.strokeRect(canvas.width-170, 10, 160, 210); /* Adjusted height */
            
            ctx.fillStyle = '#000'; ctx.font = '14px Georgia'; ctx.textAlign = 'left';
            const startX = canvas.width - 162; let yPos = 30;
            ctx.fillText(`Piso Actual: ${currentFloor}`, startX, yPos); yPos+=18; 
            ctx.fillText(`HP: ${Math.floor(player.hp)}/${Math.floor(player.maxHp)}`, startX, yPos); yPos+=18; 
            ctx.fillText(`ATK: ${Math.floor(player.atk)}`, startX, yPos); yPos+=18; 
            const defReduction = Math.min(75, player.def * 0.03); 
            ctx.fillText(`DEF: ${Math.floor(player.def)} (${(defReduction * 100).toFixed(0)}%)`, startX, yPos); yPos+=18; 
            ctx.fillText(`Nivel: ${player.level} (XP: ${player.xp})`, startX, yPos); yPos+=18;
            
            ctx.fillText('Habilidades:', startX, yPos); yPos+=18;
            ctx.font = '12px Georgia'; const currentTime = Date.now();
            
            // Display the currently equipped skills
            const skillSlots = ['habilidad1', 'habilidad2', 'habilidad3'];
            skillSlots.forEach((slot, index) => {
                const equippedSkillName = player.equipped[slot];
                const equippedSkill = skills.find(s => s.name === equippedSkillName);
                let skillText = equippedSkill ? equippedSkill.name : '(Ninguna)';
                let textColor = '#666'; 
                
                if (equippedSkill) {
                    const cooldownRemaining = Math.max(0, (skillCooldowns[equippedSkill.name] - currentTime));
                    if (equippedSkill.cooldown === 0) { 
                        skillText += " (Pasiva)";
                        textColor = '#00008B'; 
                    } else if (player.skillUsageThisFloor[equippedSkill.name]) { 
                        skillText += " (Usado)";
                        textColor = '#909090'; 
                    } else if (cooldownRemaining > 0) { 
                        skillText += ` (${(cooldownRemaining/1000).toFixed(1)}s)`;
                        textColor = '#666'; 
                    } else { 
                        skillText += ` [${index + 1}]`; 
                        textColor = '#008000'; 
                    }
                }
                ctx.fillStyle = textColor;
                ctx.fillText(skillText, startX, yPos); yPos+=16;
            });

            yPos += 5; 
            ctx.fillStyle = '#000';
            ctx.font = '13px Georgia';
            if (activeSetBonusName) {
                const bonus = setBonuses[activeSetBonusName];
                ctx.fillText(`Conjunto: ${activeSetBonusName}`, startX, yPos); yPos += 16;
                ctx.fillText(`Bonificación: ${bonus.message.split(': ')[1]}`, startX, yPos);
            } else {
                ctx.fillText('Conjunto Activo: Ninguno', startX, yPos);
            }

            if (player.hasKey) { /* ... dibujar llave ... */ }
        }

        function tryMove(dx, dy) {
            const newX = player.tileX + dx; const newY = player.tileY + dy;
            if (newX < 0 || newX >= mapWidth || newY < 0 || newY >= mapHeight) {
                return; 
            }
            // Player cannot move into a tile occupied by any monster (enemy or ally)
            if (monsters.some(m => { 
                if (m.width && m.height) {
                    return newX >= m.tileX && newX < m.tileX + m.width && newY >= m.tileY && newY < m.tileY + m.height;
                }
                return m.tileX === newX && m.tileY === newY;
            })) {
                return; 
            }

            if (map[newY] && (map[newY][newX] === 1 || map[newY][newX] === 2 || (map[newY][newX] === stairLocation.type && stairLocation.active) )) { 
                player.tileX = newX; player.tileY = newY;
                if (dx === 1) player.facingDirection = 'right'; else if (dx === -1) player.facingDirection = 'left';
                else if (dy === -1) player.facingDirection = 'up'; else if (dy === 1) player.facingDirection = 'down';
                
                // Check for chest interaction on movement
                const chest = chests.find(c => c.tileX === player.tileX && c.tileY === player.tileY);
                if (chest) {
                    openChest(chest); // Open chest automatically
                }

                if (stairLocation.active && newX === stairLocation.x && newY === stairLocation.y) {
                    handleFloorTransition();
                }
            } 
        }
        
        function handleFloorTransition() {
            if (currentFloor < maxFloors) {
                currentFloor++;
                generateFloor(); 
            } 
        }

        function performAttack() {
            if (player.isAttacking) return; 

            // Hard difficulty miss chance
            if (selectedDifficulty === 'dificil' && Math.random() < 0.05) { 
                showMessage("¡Fallaste el ataque!");
                player.isAttacking = true; 
                player.attackAnimFrame = 0;
                return; 
            }

            player.isAttacking = true;
            player.attackAnimFrame = 0; 

            const equippedWeapon = player.equipped.weapon;
            let targetTiles = []; 
            let projectileType = null;
            let projectileRange = 1; 

            // --- Auto-targeting logic: Find the closest enemy and set facing direction ---
            let nearestEnemy = null;
            let minDist = Infinity;
            monsters.filter(m => !m.isMinion).forEach(m => {
                const dist = Math.abs(player.tileX - m.tileX) + Math.abs(player.tileY - m.tileY);
                if (dist < minDist) {
                    minDist = dist;
                    nearestEnemy = m;
                }
            });

            if (nearestEnemy) {
                const dxToEnemy = nearestEnemy.tileX - player.tileX;
                const dyToEnemy = nearestEnemy.tileY - player.tileY;

                if (Math.abs(dxToEnemy) > Math.abs(dyToEnemy)) {
                    player.facingDirection = dxToEnemy > 0 ? 'right' : 'left';
                } else if (Math.abs(dyToEnemy) > 0) {
                    player.facingDirection = dyToEnemy > 0 ? 'down' : 'up';
                }
            }


            // Determine target tiles based on weapon type
            if (equippedWeapon) {
                switch (equippedWeapon.name) {
                    case 'Arco del Bosque':
                        projectileType = 'arrow';
                        projectileRange = 3; // Increased range to 3
                        break;
                    case 'Rayo de Oscuridad':
                        projectileType = 'dark_ray';
                        projectileRange = 3; // Increased range to 3
                        break;
                    case 'Libro Celestial':
                        projectileType = 'celestial_ray'; 
                        projectileRange = 3; // Increased range to 3
                        break;
                    case 'Maza de Guerra':
                        // Hits up to 2 monsters in front
                        if (player.facingDirection === 'right') {
                            targetTiles.push({ x: player.tileX + 1, y: player.tileY });
                            targetTiles.push({ x: player.tileX + 1, y: player.tileY - 1 });
                            targetTiles.push({ x: player.tileX + 1, y: player.tileY + 1 });
                        } else if (player.facingDirection === 'left') {
                            targetTiles.push({ x: player.tileX - 1, y: player.tileY });
                            targetTiles.push({ x: player.tileX - 1, y: player.tileY - 1 });
                            targetTiles.push({ x: player.tileX - 1, y: player.tileY + 1 });
                        } else if (player.facingDirection === 'up') {
                            targetTiles.push({ x: player.tileX, y: player.tileY - 1 });
                            targetTiles.push({ x: player.tileX - 1, y: player.tileY - 1 });
                            targetTiles.push({ x: player.tileX + 1, y: player.tileY - 1 });
                        } else if (player.facingDirection === 'down') {
                            targetTiles.push({ x: player.tileX, y: player.tileY + 1 });
                            targetTiles.push({ x: player.tileX - 1, y: player.tileY + 1 });
                            targetTiles.push({ x: player.tileX + 1, y: player.tileY + 1 });
                        }
                        break;
                    default: 
                        if (player.facingDirection === 'right') targetTiles.push({ x: player.tileX + 1, y: player.tileY });
                        else if (player.facingDirection === 'left') targetTiles.push({ x: player.tileX - 1, y: player.tileY });
                        else if (player.facingDirection === 'up') targetTiles.push({ x: player.tileX, y: player.tileY - 1 });
                        else if (player.facingDirection === 'down') targetTiles.push({ x: player.tileX, y: player.tileY + 1 });
                        break;
                }
            } else { 
                if (player.facingDirection === 'right') targetTiles.push({ x: player.tileX + 1, y: player.tileY });
                else if (player.facingDirection === 'left') targetTiles.push({ x: player.tileX - 1, y: player.tileY });
                else if (player.facingDirection === 'up') targetTiles.push({ x: player.tileX, y: player.tileY - 1 });
                else if (player.facingDirection === 'down') targetTiles.push({ x: player.tileX, y: player.tileY + 1 });
            }

            let monstersHit = [];
            if (!projectileType) { 
                for (const targetCoord of targetTiles) {
                    const monster = monsters.find(m => !m.isMinion && (m.width && m.height ? (targetCoord.x >= m.tileX && targetCoord.x < m.tileX + m.width && targetCoord.y >= m.tileY && targetCoord.y < m.tileY + m.height) : (m.tileX === targetCoord.x && m.tileY === targetCoord.y)));
                    if (monster && !monstersHit.includes(monster)) {
                        monstersHit.push(monster);
                        if (equippedWeapon && equippedWeapon.name === 'Maza de Guerra' && monstersHit.length >= 2) {
                            break; 
                        }
                    }
                }
            }
            

            const offsetX = Math.max(0, Math.min(player.tileX*tileSize - canvas.width/2 + tileSize/2, mapWidth*tileSize - canvas.width));
            const offsetY = Math.max(0, Math.min(player.tileY*tileSize - canvas.height/2 + tileSize/2, mapHeight*tileSize - canvas.height));
            const playerScreenX = player.tileX * tileSize - offsetX;
            const playerScreenY = player.tileY * tileSize - offsetY;

            // Handle projectile creation
            if (projectileType) { 
                let dx = 0, dy = 0;
                if (nearestEnemy) {
                    dx = nearestEnemy.tileX - player.tileX;
                    dy = nearestEnemy.tileY - player.tileY;
                } else {
                    if (player.facingDirection === 'right') dx = 1;
                    else if (player.facingDirection === 'left') dx = -1;
                    else if (player.facingDirection === 'up') dy = -1;
                    else if (player.facingDirection === 'down') dy = 1;
                }
                
                let isCriticalProjectile = Math.random() < (0.2 + player.criticalChanceBonus);
                if (player.luckBoostEndTime > Date.now()) {
                    isCriticalProjectile = isCriticalProjectile || (Math.random() < 0.05);
                }

                if (equippedWeapon.name === 'Libro Celestial') {
                    player.celestialBookCritCounter++;
                    if (player.celestialBookCritCounter >= 10) {
                        isCriticalProjectile = true;
                        player.celestialBookCritCounter = 0;
                        showMessage("¡Libro Celestial: Golpe Crítico garantizado!");
                    }
                }
                
                projectiles.push(new Projectile(player.tileX, player.tileY, dx, dy, projectileType, 'player', player.atk, isCriticalProjectile, projectileRange));
            }


            // Apply effects to hit monsters (for melee and immediate hits)
            monstersHit.forEach(monsterToAttack => {
                let isCritical = Math.random() < (0.2 + player.criticalChanceBonus); 
                if (player.luckBoostEndTime > Date.now()) { 
                    isCritical = isCritical || (Math.random() < 0.05); 
                }

                const damageMultiplier = isCritical ? 1.5 : 1;
                let damage = Math.floor(player.atk * damageMultiplier);

                if (player.nextHitCritical) { 
                    damage *= 1.5;
                    player.nextHitCritical = false; 
                }
                
                if (monsterToAttack.isWeakened && Date.now() < monsterToAttack.weaknessEndTime) {
                    damage *= 1.05; 
                }

                monsterToAttack.hp -= damage;
                monsterToAttack.hitFrame = isCritical ? 10 : 5;
                
                const monsterScreenX = monsterToAttack.tileX * tileSize - offsetX;
                const monsterScreenY = monsterToAttack.tileY * tileSize - offsetY;
                
                damageTexts.push({
                    x: monsterScreenX + tileSize/2 * (monsterToAttack.width || 1), 
                    y: monsterScreenY - 10 + tileSize/2 * (monsterToAttack.height || 1) - tileSize/2, 
                    text: isCritical ? `¡CRÍTICO! ${Math.floor(damage)}` : `${Math.floor(damage)}`,
                    color: isCritical ? '#ff0000' : '#ffffff', size: isCritical ? 24 : 16,
                    life: 40, velY: -1.5
                });
                if (isCritical) {
                    screenShake = 8; 
                    criticalHitEffects.push({ x: monsterScreenX, y: monsterScreenY, size: tileSize * (monsterToAttack.width || 1) * 1.5, life: 15, monster: monsterToAttack });

                }
                
                if (player.soulExtractionActive) {
                    const hpRecovered = Math.floor(damage * 0.05);
                    if (hpRecovered > 0) { 
                        player.hp = Math.min(player.maxHp, player.hp + hpRecovered); 
                        damageTexts.push({ 
                            x: playerScreenX + tileSize/2, y: playerScreenY - 5, 
                            text: `+${hpRecovered} HP`,
                            color: '#00ff00', size: 14, life: 30, velY: -1
                        });
                    }
                }

                // Weapon-specific effects on hit
                if (equippedWeapon) {
                    const currentTime = Date.now();
                    if (equippedWeapon.name === 'Guadaña Helada') {
                        monsterToAttack.isAttackSlowed = true;
                        monsterToAttack.attackSlowEndTime = currentTime + 3000; 
                        showMessage(`Guadaña Helada: ${monsterToAttack.type} ralentizado.`);
                    } else if (equippedWeapon.name === 'Daga de Poder') {
                        const bleedChance = 0.25; 
                        if (Math.random() < bleedChance) {
                            monsterToAttack.isBleeding = true;
                            monsterToAttack.bleedingDamagePerTick = Math.floor(player.atk * 0.05); 
                            monsterToAttack.bleedingTickInterval = 1000; 
                            monsterToAttack.bleedingNextTickTime = currentTime + monsterToAttack.bleedingTickInterval;
                            monsterToAttack.bleedingEndTime = currentTime + 5000; 
                            showMessage(`Daga de Poder: ${monsterToAttack.type} está sangrando.`);
                        }
                    } else if (equippedWeapon.name === 'Maza de Guerra' && monstersHit.length > 1) {
                        warMaceShockwave = { x: player.tileX, y: player.tileY, life: 15 }; 
                    }
                }

                if (monsterToAttack.hp <= 0) {
                    let xpGained = monsterToAttack.xp;
                    if (activeSetBonusName === 'Mago' && setBonuses.Mago.xpGain_percent) {
                        xpGained = Math.floor(xpGained * (1 + setBonuses.Mago.xpGain_percent));
                    }
                    player.xp += xpGained;

                    player.enemiesDefeatedThisRun++; 
                    
                    // HP recovery only on critical hit (5% of monster's max HP)
                    if (isCritical) {
                        const healthRecovered = Math.floor(monsterToAttack.maxHp * 0.05); 
                        if (healthRecovered > 0) { 
                            player.hp = Math.min(player.maxHp, player.hp + healthRecovered); 
                            damageTexts.push({ 
                                x: playerScreenX + tileSize/2, y: playerScreenY - 5, 
                                text: `+${healthRecovered} HP`, // Corrected: Use healthRecovered
                                color: '#00ff00', 
                                size: 14, life: 30, velY: -1
                            });
                        }
                    }

                    // Rayo de Oscuridad: HP recovery on enemy defeated
                    if (equippedWeapon && equippedWeapon.name === 'Rayo de Oscuridad') {
                        player.darkRayEnemiesDefeated++;
                        if (player.darkRayEnemiesDefeated >= 10) {
                            const healedAmount = Math.floor(player.maxHp * 0.05); 
                            if (healedAmount > 0) { 
                                player.hp = Math.min(player.maxHp, player.hp + healedAmount);
                                showMessage("¡Rayo de Oscuridad: ¡5% HP recuperado!");
                            }
                            player.darkRayEnemiesDefeated = 0;
                        }
                    }


                    if (monsterToAttack.dropsKey) player.hasKey = true;
                    
                    let monsterGoldDrop = Math.floor(Math.random() * (currentFloor)); 
                    if (monsterToAttack.type === 'boss') monsterGoldDrop = 25 + currentFloor * 10;
                    else if (monsterToAttack.type === 'mini-boss') monsterGoldDrop = 10 + currentFloor * 5;
                    else if (monsterToAttack.type === 'final-arachnid-boss') monsterGoldDrop = 100; 
                    
                    // Apply Noble set bonus for gold find
                    if (activeSetBonusName === 'Noble' && setBonuses.Noble.goldFind_percent) {
                        monsterGoldDrop = Math.floor(monsterGoldDrop * (1 + setBonuses.Noble.goldFind_percent));
                    }
                    player.gold += monsterGoldDrop;
                    
                    const defeatedMonsterType = monsterToAttack.type;
                    monsters = monsters.filter(m => m !== monsterToAttack);
                    checkLevelUp();

                    if (defeatedMonsterType === 'final-arachnid-boss' && currentFloor === maxFloors) {
                        lastGameScore = player.xp;
                        lastEnemiesDefeated = player.enemiesDefeatedThisRun;
                        finalOutcomeMessage = "Haz Completado la Mazmorra";
                        finalOutcomeMessageLine2 = "Haz superado la clase E";
                        gameOver = true; 
                    } else if (monsters.filter(m => !m.isMinion).length === 0 && currentFloor < maxFloors) { 
                        stairLocation.active = true;
                        map[stairLocation.y][stairLocation.x] = stairLocation.type; 
                        showMessage("¡Todos los enemigos derrotados! Una escalera ha aparecido.");
                    }
                }
            });
        }


        function openChest(chest) { // Modified to take chest directly
            if (chest) {
                const offsetX = Math.max(0, Math.min(player.tileX * tileSize - canvas.width / 2 + tileSize / 2, mapWidth * tileSize - canvas.width));
                const offsetY = Math.max(0, Math.min(player.tileY * tileSize - canvas.height / 2 + tileSize / 2, mapHeight * tileSize - canvas.height));
                const playerScreenX = player.tileX * tileSize - offsetX;
                const playerScreenY = player.tileY * tileSize - offsetY;

                if (chest.gear.type === 'potion') {
                    if (player.hp < player.maxHp) {
                        const healedAmount = chest.gear.heal;
                        player.hp = Math.min(player.maxHp, player.hp + healedAmount);
                        showMessage(`¡Encontraste una ${chest.gear.name} y recuperaste ${healedAmount} HP!`);
                        damageTexts.push({
                            x: playerScreenX + tileSize / 2, y: playerScreenY - 5,
                            text: `+${healedAmount} HP`,
                            color: '#00ff00', size: 16, life: 40, velY: -1
                        });
                    } else {
                        showMessage("Tu vida ya está al máximo.");
                    }
                } else { 
                    player.inventory.push(chest.gear);
                    showMessage(`Encontraste: ${chest.gear.name}`);
                    if (isInventoryOpen) updateInventoryDisplay();
                }
                // This line updates the map to remove the chest visually after it's opened.
                map[chest.tileY][chest.tileX] = 1; 
                // --- FIX END: Chest Disappearance ---
                chests = chests.filter(c => c !== chest);
            }
        }

        // Define set bonuses
        const setBonuses = {
            'Hierro': { def_percent: 0.10, message: "¡Bonificación de Conjunto de Hierro: +10% Defensa!" },
            'Caballero': { maxHp_percent: 0.10, message: "¡Bonificación de Conjunto de Caballero: +10% HP Máximo!" },
            'Demonio': { atk_percent: 0.15, message: "¡Bonificación de Conjunto de Demonio: +15% Ataque!" },
            'León': { atk_flat: 10, def_flat: 5, message: "¡Bonificación de Conjunto de León: +10 Ataque, +5 Defensa!" },
            'Asesinato': { spd_percent: 0.10, critical_flat: 0.05, message: "¡Bonificación de Conjunto de Asesinato: +10% Velocidad, +5% Crítico!" },
            'Noble': { goldFind_percent: 0.15, maxHp_flat: 5, message: "¡Bonificación de Conjunto Noble: +15% Oro Encontrado, +5 HP Máximo!" },
            'Mago': { xpGain_percent: 0.20, maxHp_percent: 0.10, message: "¡Bonificación de Conjunto de Mago: +20% XP, +10% HP Máximo!" }
        };

        // Track active set bonus to prevent re-applying messages
        let activeSetBonusName = null;

        function applySetBonuses() {
            let currentFullSetDetected = null;
            const equippedSetCounts = {};
            const requiredSlotsForFullSet = ['helmet', 'armor', 'gloves', 'boots']; 

            // Count items from each set
            requiredSlotsForFullSet.forEach(slot => {
                if (player.equipped[slot] && player.equipped[slot].set) {
                    const setName = player.equipped[slot].set;
                    equippedSetCounts[setName] = (equippedSetCounts[setName] || 0) + 1;
                }
            });

            for (const setName in equippedSetCounts) {
                if (equippedSetCounts[setName] === requiredSlotsForFullSet.length) {
                    currentFullSetDetected = setName;
                    break; 
                }
            }

            // If a new full set is active, show message
            if (currentFullSetDetected && currentFullSetDetected !== activeSetBonusName) {
                const bonus = setBonuses[currentFullSetDetected];
                if (bonus) {
                    showMessage(bonus.message);
                }
            }
            // If no full set is active, but one was previously, clear the active bonus
            else if (!currentFullSetDetected && activeSetBonusName) {
            }
            activeSetBonusName = currentFullSetDetected; 

            // Prepare bonuses to return to updateStats
            const bonusesToApply = {
                atk_flat: 0, def_flat: 0, maxHp_flat: 0, critical_flat: 0,
                atk_percent: 0, def_percent: 0, maxHp_percent: 0, spd_percent: 0, goldFind_percent: 0, xpGain_percent: 0
            };

            if (activeSetBonusName) {
                const bonus = setBonuses[activeSetBonusName];
                if (bonus) {
                    if (bonus.atk_flat) bonusesToApply.atk_flat = bonus.atk_flat;
                    if (bonus.def_flat) bonusesToApply.def_flat = bonus.def_flat;
                    if (bonus.maxHp_flat) bonusesToApply.maxHp_flat = bonus.maxHp_flat;
                    if (bonus.critical_flat) bonusesToApply.critical_flat = bonus.critical_flat;

                    if (bonus.atk_percent) bonusesToApply.atk_percent = bonus.atk_percent;
                    if (bonus.def_percent) bonusesToApply.def_percent = bonus.def_percent;
                    if (bonus.maxHp_percent) bonusesToApply.maxHp_percent = bonus.maxHp_percent;
                    if (bonus.spd_percent) bonusesToApply.spd_percent = bonus.spd_percent;
                    if (bonus.goldFind_percent) bonusesToApply.goldFind_percent = bonus.goldFind_percent;
                    if (bonus.xpGain_percent) bonusesToApply.xpGain_percent = bonus.xpGain_percent;
                }
            }
            return bonusesToApply;
        }

        function updateStats() {
            // Reset stats to base values first
            player.atk = player.baseAtk;
            player.def = player.baseDef;
            player.spd = player.baseSpd; 
            player.maxHp = 100 + (player.level - 1) * 20;
            player.criticalChanceBonus = 0; 

            // Reset attack interval to default
            attackInterval = 400; 

            // Reset mini-shield properties
            player.hasMiniShield = false;
            player.miniShieldHP = 0;
            player.miniShieldMaxHP = 0;


            // Apply equipped item bonuses (flat additions)
            for (const slot in player.equipped) {
                const item = player.equipped[slot];
                if (item && !slot.startsWith('habilidad')) {
                    if (item.atk) player.atk += item.atk;
                    if (item.def) player.def += item.def;
                    if (item.spd) player.spd += item.spd * 0.2; 
                    if (item.hp) player.maxHp += item.hp;
                    if (item.critical) player.criticalChanceBonus += item.critical;
                }
            }

            // Get and apply set bonuses (flat and percentage)
            const currentSetBonuses = applySetBonuses();

            // Apply flat set bonuses
            player.atk += (currentSetBonuses.atk_flat || 0);
            player.def += (currentSetBonuses.def_flat || 0);
            player.maxHp += (currentSetBonuses.maxHp_flat || 0);
            player.criticalChanceBonus += (currentSetBonuses.critical_flat || 0);

            // Apply percentage set bonuses (to current total)
            if (currentSetBonuses.atk_percent) player.atk *= (1 + currentSetBonuses.atk_percent);
            if (currentSetBonuses.def_percent) player.def *= (1 + currentSetBonuses.def_percent);
            if (currentSetBonuses.maxHp_percent) player.maxHp *= (1 + currentSetBonuses.maxHp_percent);
            if (currentSetBonuses.spd_percent) player.spd *= (1 + currentSetBonuses.spd_percent);

            // Apply weapon-specific passive effects
            if (player.equipped.weapon && player.equipped.weapon.attackSpeed) {
                attackInterval = player.equipped.weapon.attackSpeed;
            }

            // Apply temporary buffs (Speed, Fury, Stealth, etc.) - these should be applied last
            const currentTime = Date.now();
            if (player.isSpeedBoosted && currentTime < player.speedBoostEndTime) {
                player.spd *= 1.5; 
            }
            if (player.furyActive && player.hp <= player.maxHp * 0.25) {
                player.atk *= 2;
            }
            if (player.stealthActive && currentTime < player.stealthEndTime) {
                player.atk = Math.floor(player.atk * player.stealthStatMultiplier);
                player.def = Math.floor(player.def * player.stealthStatMultiplier);
                player.spd = player.spd * player.stealthStatMultiplier;
            }
            // Apply slow effect if active
            if (player.isSlowed && currentTime < player.slowEndTime) {
                player.spd *= 0.5; // Reduce speed by 50%
            }


            // Ensure HP doesn't exceed new maxHp
            player.hp = Math.min(player.hp, player.maxHp);
            loadSprites(); 
        }

        function toggleInventory() {
            isInventoryOpen = !isInventoryOpen;
            if(isInventoryOpen) {
                isSkillMenuOpen = false; 
                isEquipmentOpen = false;
            }
            document.getElementById('inventoryMenu').style.display = isInventoryOpen ? 'block' : 'none';
            document.getElementById('skillMenu').style.display = 'none'; 
            document.getElementById('equipmentMenu').style.display = 'none'; 
            if (isInventoryOpen) updateInventoryDisplay();
        }
        function updateInventoryDisplay() {
            document.getElementById('playerGoldInventory').textContent = player.gold;
            const gearUl = document.getElementById('gearList'); gearUl.innerHTML = '';
            player.inventory.forEach((gear, i) => { 
                const li = document.createElement('li');
                
                let statsText = '';
                if(gear.type === 'potion') statsText = ` (Cura: ${gear.heal||0})`;
                else { 
                    const stats = [];
                    if (gear.atk) stats.push(`ATK: ${Math.floor(gear.atk)}`);
                    if (gear.def) stats.push(`DEF: ${Math.floor(gear.def)}`); 
                    if (gear.spd) stats.push(`SPD: ${gear.spd.toFixed(1)}`); 
                    if (gear.critical) stats.push(`CRIT: ${(gear.critical*100).toFixed(0)}%`);
                    statsText = stats.length > 0 ? ` (${stats.join(', ')})` : '';
                }

                li.textContent = `${gear.name}${statsText}`; 
                
                // Check if the item is equipped
                let isEquipped = false;
                for (const slot in player.equipped) {
                    if (player.equipped[slot] && player.equipped[slot].name === gear.name) {
                        isEquipped = true;
                        break;
                    }
                }

                if (isEquipped) {
                    li.classList.add('inventory-equipped');
                } else {
                    li.classList.add('inventory-unequipped');
                }

                if (i === selectedIndex) li.classList.add('selected');
                gearUl.appendChild(li);
            });
        }
        function handleInventoryInput(e) {
            e.preventDefault(); e.stopPropagation();
            if (e.code === 'ArrowUp') {
                selectedIndex = Math.max(0, selectedIndex - 1);
            }
            else if (e.code === 'ArrowDown') {
                selectedIndex = Math.min(player.inventory.length - 1, selectedIndex + 1);
            }
            else if (e.code === 'Enter' && player.inventory.length > 0) {
                const item = player.inventory[selectedIndex];
                if (item.type === 'potion') {
                    if (player.hp < player.maxHp) {
                        const healedAmount = item.heal;
                        player.hp = Math.min(player.maxHp, player.hp + healedAmount);
                        showMessage(`Usaste ${item.name} y recuperaste ${healedAmount} HP.`);
                        
                        const offsetX = Math.max(0, Math.min(player.tileX*tileSize - canvas.width/2 + tileSize/2, mapWidth*tileSize - canvas.width));
                        const offsetY = Math.max(0, Math.min(player.tileY*tileSize - canvas.height/2 + tileSize/2, mapHeight*tileSize - canvas.height));
                        const playerScreenX = player.tileX * tileSize - offsetX;
                        const playerScreenY = player.tileY * tileSize - offsetY;
                        damageTexts.push({
                            x: playerScreenX + tileSize/2, y: playerScreenY - 5,
                            text: `+${healedAmount} HP`,
                            color: '#00ff00', size: 16, life: 40, velY: -1
                        });

                        player.inventory.splice(selectedIndex, 1);
                        if (selectedIndex >= player.inventory.length && player.inventory.length > 0) {
                            selectedIndex = player.inventory.length - 1;
                        } else if (player.inventory.length === 0) {
                            selectedIndex = 0; 
                        }
                        updateStats(); 
                    } else {
                        showMessage("Tu vida ya está al máximo.");
                    }
                } else { 
                    showMessage("Solo puedes usar pociones desde aquí.");
                }
            } else if (e.code === 'KeyI' || e.code === 'Escape') {
                toggleInventory(); 
            }
            updateInventoryDisplay();
        }

        function toggleSkillMenu() {
            isSkillMenuOpen = !isSkillMenuOpen;
            if(isSkillMenuOpen) {
                isInventoryOpen = false; 
                isEquipmentOpen = false; 
            }
            document.getElementById('skillMenu').style.display = isSkillMenuOpen ? 'block' : 'none';
            document.getElementById('inventoryMenu').style.display = 'none'; 
            document.getElementById('equipmentMenu').style.display = 'none'; 
            if (isSkillMenuOpen) updateSkillDisplay();
        }
        function updateSkillDisplay() {
            document.getElementById('skillPoints').textContent = player.skillPoints;
            const skillUl = document.getElementById('skillList'); skillUl.innerHTML = '';
            skills.forEach((skill, i) => {
                const li = document.createElement('li');
                let statusClass = 'locked';
                let statusText = '';
                
                const isEquippedInSlot = player.equipped.habilidad1 === skill.name || 
                                         player.equipped.habilidad2 === skill.name || 
                                         player.equipped.habilidad3 === skill.name;

                if (player.permanentlyLearnedSkills.includes(skill.name)) {
                    statusClass = 'unlocked'; 
                    statusText = isEquippedInSlot ? ' (Activa)' : ' (Desbloqueada)';
                    if (skill.cooldown !== 0 && player.skillUsageThisFloor[skill.name]) { 
                        li.classList.add('skill-used');
                    }
                } else if (player.skillPoints >= skill.cost && (!skill.prereq || player.permanentlyLearnedSkills.includes(skill.prereq))) {
                    statusClass = 'available';
                    statusText = ' (Desbloquear)';
                } else {
                    statusClass = 'locked';
                    statusText = ' (Bloqueada)'; 
                }

                li.textContent = `${skill.name} - ${skill.effect}${statusText}`; 
                li.className = statusClass;
                
                if (isEquippedInSlot) {
                    li.classList.add('skill-equipped');
                }

                if (i === selectedSkillIndex) li.classList.add('selected'); 
                skillUl.appendChild(li);
            });
        }
        function handleSkillInput(e) {
            e.preventDefault(); e.stopPropagation();
            if (e.code === 'ArrowUp') selectedSkillIndex = Math.max(0, selectedSkillIndex - 1);
            else if (e.code === 'ArrowDown') selectedSkillIndex = Math.min(skills.length - 1, selectedSkillIndex + 1);
            else if (e.code === 'Enter') {
                const skill = skills[selectedSkillIndex];
                if (player.permanentlyLearnedSkills.includes(skill.name)) {
                    showMessage("Esta habilidad ya está desbloqueada. Equípala en el menú de Equipo.");
                } else if (player.skillPoints >= skill.cost && (!skill.prereq || player.permanentlyLearnedSkills.includes(skill.prereq))) {
                    player.skillPoints -= skill.cost; 
                    player.permanentlyLearnedSkills.push(skill.name); 
                    showMessage(`¡Habilidad '${skill.name}' desbloqueada!`);
                } else if (player.skillPoints < skill.cost) {
                    showMessage("No tienes suficientes puntos de habilidad.");
                } else {
                    showMessage(`Necesitas desbloquear '${skill.prereq}' primero.`);
                }
            } else if (e.code === 'KeyY' || e.code === 'Escape') toggleSkillMenu();
            updateSkillDisplay();
        }

        // Updated equipmentSlotsOrder to include new skill slots
        const equipmentSlotsOrder = ['helmet', 'armor', 'gloves', 'boots', 'weapon', 'habilidad1', 'habilidad2', 'habilidad3']; 
        const equipmentSlotNames = {
            'helmet': 'Casco',
            'armor': 'Armadura',
            'gloves': 'Guantes',
            'boots': 'Botas',
            'weapon': 'Arma',
            'habilidad1': 'Habilidad 1', 
            'habilidad2': 'Habilidad 2',
            'habilidad3': 'Habilidad 3'
        };

        function toggleEquipmentMenu() {
            isEquipmentOpen = !isEquipmentOpen;
            if (isEquipmentOpen) {
                isInventoryOpen = false;
                isSkillMenuOpen = false;
                difficultyScreen.style.display = 'none';
                equipmentMenu.style.display = 'block';
                playMusic('equipmentOpen'); // Play sound when opening equipment menu
            } else {
                difficultyScreen.style.display = 'flex';
                equipmentMenu.style.display = 'none';
            }
            if (isEquipmentOpen) updateEquipmentDisplay();
        }

        function updateEquipmentDisplay() {
            equippedSlotsDiv.innerHTML = '';
            equipmentMenuInstructions.textContent = ""; 

            equipmentSlotsOrder.forEach((slotType, i) => {
                const div = document.createElement('div');
                div.classList.add('equipment-slot-row');
                if (i === selectedEquipmentSlotIndex) {
                    div.classList.add('selected');
                }

                const leftButton = document.createElement('button');
                leftButton.classList.add('nav-button', 'left-arrow');
                leftButton.textContent = '<';
                leftButton.dataset.direction = 'left';
                leftButton.dataset.slotType = slotType;
                div.appendChild(leftButton);

                const itemNameSpan = document.createElement('span');
                if (slotType.startsWith('habilidad')) { 
                    const equippedSkillName = player.equipped[slotType];
                    itemNameSpan.textContent = `${equipmentSlotNames[slotType]}: ${equippedSkillName ? equippedSkillName : '(Ninguna)'}`;
                } else { 
                    const item = player.equipped[slotType];
                    let statsText = '';
                    if (item) {
                        const stats = [];
                        if (item.atk) stats.push(`ATK: ${Math.floor(item.atk)}`);
                        if (item.def) stats.push(`DEF: ${Math.floor(item.def)}`); 
                        if (item.spd) stats.push(`SPD: ${item.spd.toFixed(1)}`); 
                        if (item.hp) stats.push(`HP: ${Math.floor(item.hp)}`); 
                        if (item.critical) stats.push(`CRIT: ${(item.critical*100).toFixed(0)}%`);
                        statsText = stats.length > 0 ? ` (${stats.join(', ')})` : '';
                    }
                    itemNameSpan.textContent = `${equipmentSlotNames[slotType]}: ${item ? item.name : '(Vacío)'}${statsText}`;
                }
                div.appendChild(itemNameSpan);

                const rightButton = document.createElement('button');
                rightButton.classList.add('nav-button', 'right-arrow');
                rightButton.textContent = '>';
                rightButton.dataset.direction = 'right';
                rightButton.dataset.slotType = slotType;
                div.appendChild(rightButton);

                equippedSlotsDiv.appendChild(div);
            });
        }

        equippedSlotsDiv.addEventListener('click', (e) => {
            const target = e.target;
            if (target.classList.contains('nav-button')) {
                const direction = target.dataset.direction;
                const slotType = target.dataset.slotType;

                if (slotType.startsWith('habilidad')) { 
                    const otherEquippedSkills = [];
                    if (slotType !== 'habilidad1' && player.equipped.habilidad1) otherEquippedSkills.push(player.equipped.habilidad1);
                    if (slotType !== 'habilidad2' && player.equipped.habilidad2) otherEquippedSkills.push(player.equipped.habilidad2);
                    if (slotType !== 'habilidad3' && player.equipped.habilidad3) otherEquippedSkills.push(player.equipped.habilidad3);

                    const availableSkills = skills.map(s => s.name).filter(skillName => !otherEquippedSkills.includes(skillName));
                    
                    availableSkills.unshift(null); 

                    let currentIndex = availableSkills.indexOf(player.equipped[slotType]);
                    if (currentIndex === -1) currentIndex = 0; 

                    let newIndex = currentIndex;
                    if (direction === 'right') {
                        newIndex++;
                        if (newIndex >= availableSkills.length) {
                            newIndex = 0; 
                        }
                    } else { 
                        newIndex--;
                        if (newIndex < 0) {
                            newIndex = availableSkills.length - 1; 
                        }
                    }

                    player.equipped[slotType] = availableSkills[newIndex];
                    if (player.equipped[slotType]) {
                        showMessage(`Equipado: ${player.equipped[slotType]} en ${equipmentSlotNames[slotType]}`);
                    } else {
                        showMessage(`Desequipado: ${equipmentSlotNames[slotType]}`);
                    }
                } else { 
                    const equippableItemsForSlot = player.inventory.filter(item => item.type === slotType);
                    
                    equippableItemsForSlot.unshift(null);

                    let currentIndex = -1; 
                    const equippedItem = player.equipped[slotType];
                    if (equippedItem) {
                        currentIndex = equippableItemsForSlot.findIndex(item => item && item.name === equippedItem.name);
                    }
                    if (currentIndex === -1) currentIndex = 0;
                    let newIndex = currentIndex;
                    if (direction === 'right') {
                        newIndex++;
                        if (newIndex >= equippableItemsForSlot.length) {
                            newIndex = 0; 
                        }
                    } else { 
                        newIndex--;
                        if (newIndex < 0) {
                            newIndex = equippableItemsForSlot.length - 1; 
                        }
                    }

                    player.equipped[slotType] = equippableItemsForSlot[newIndex];
                    if (player.equipped[slotType]) {
                        showMessage(`Equipado: ${player.equipped[slotType].name}`);
                    } else {
                        showMessage(`Desequipado: ${equipmentSlotNames[slotType]}`);
                    }
                }
                updateStats();
                updateEquipmentDisplay();
            }
        });

        function handleEquipmentInput(e) {
            e.preventDefault(); 
            e.stopPropagation(); 

            if (e.code === 'ArrowUp') {
                selectedEquipmentSlotIndex = Math.max(0, selectedEquipmentSlotIndex - 1);
            } else if (e.code === 'ArrowDown') {
                selectedEquipmentSlotIndex = Math.min(equipmentSlotsOrder.length - 1, selectedEquipmentSlotIndex + 1);
            } else if (e.code === 'ArrowLeft') {
                const currentSlotType = equipmentSlotsOrder[selectedEquipmentSlotIndex];
                const leftButton = equippedSlotsDiv.querySelector(`.equipment-slot-row:nth-child(${selectedEquipmentSlotIndex + 1}) .left-arrow`);
                if (leftButton) left(currentSlotType);
            } else if (e.code === 'ArrowRight') {
                const currentSlotType = equipmentSlotsOrder[selectedEquipmentSlotIndex];
                const rightButton = equippedSlotsDiv.querySelector(`.equipment-slot-row:nth-child(${selectedEquipmentSlotIndex + 1}) .right-arrow`);
                if (rightButton) right(currentSlotType);
            } else if (e.code === 'KeyO' || e.code === 'Escape') {
                toggleEquipmentMenu(); 
                return;
            }
            updateEquipmentDisplay();
        }

        // Helper functions for equipment menu navigation via keyboard
        function left(slotType) {
            if (slotType.startsWith('habilidad')) {
                const otherEquippedSkills = [];
                if (slotType !== 'habilidad1' && player.equipped.habilidad1) otherEquippedSkills.push(player.equipped.habilidad1);
                if (slotType !== 'habilidad2' && player.equipped.habilidad2) otherEquippedSkills.push(player.equipped.habilidad2);
                if (slotType !== 'habilidad3' && player.equipped.habilidad3) otherEquippedSkills.push(player.equipped.habilidad3);
                const availableSkills = skills.map(s => s.name).filter(skillName => !otherEquippedSkills.includes(skillName));
                availableSkills.unshift(null);

                let currentIndex = availableSkills.indexOf(player.equipped[slotType]);
                if (currentIndex === -1) currentIndex = 0;
                let newIndex = currentIndex - 1;
                if (newIndex < 0) newIndex = availableSkills.length - 1;
                player.equipped[slotType] = availableSkills[newIndex];
                if (player.equipped[slotType]) {
                    showMessage(`Equipado: ${player.equipped[slotType]} en ${equipmentSlotNames[slotType]}`);
                } else {
                    showMessage(`Desequipado: ${equipmentSlotNames[slotType]}`);
                }
            } else {
                const equippableItemsForSlot = player.inventory.filter(item => item.type === slotType);
                equippableItemsForSlot.unshift(null);

                let currentIndex = -1;
                const equippedItem = player.equipped[slotType];
                if (equippedItem) {
                    currentIndex = equippableItemsForSlot.findIndex(item => item && item.name === equippedItem.name);
                }
                if (currentIndex === -1) currentIndex = 0;
                let newIndex = currentIndex - 1;
                if (newIndex < 0) newIndex = equippableItemsForSlot.length - 1;
                player.equipped[slotType] = equippableItemsForSlot[newIndex];
                if (player.equipped[slotType]) {
                    showMessage(`Equipado: ${player.equipped[slotType].name}`);
                } else {
                    showMessage(`Desequipado: ${equipmentSlotNames[slotType]}`);
                }
            }
            updateStats();
        }

        function right(slotType) {
            if (slotType.startsWith('habilidad')) {
                const otherEquippedSkills = [];
                if (slotType !== 'habilidad1' && player.equipped.habilidad1) otherEquippedSkills.push(player.equipped.habilidad1);
                if (slotType !== 'habilidad2' && player.equipped.habilidad2) otherEquippedSkills.push(player.equipped.habilidad2);
                if (slotType !== 'habilidad3' && player.equipped.habilidad3) otherEquippedSkills.push(player.equipped.habilidad3);
                const availableSkills = skills.map(s => s.name).filter(skillName => !otherEquippedSkills.includes(skillName));
                availableSkills.unshift(null);

                let currentIndex = availableSkills.indexOf(player.equipped[slotType]);
                if (currentIndex === -1) currentIndex = 0;
                let newIndex = currentIndex + 1;
                if (newIndex >= availableSkills.length) newIndex = 0;
                player.equipped[slotType] = availableSkills[newIndex];
                if (player.equipped[slotType]) {
                    showMessage(`Equipado: ${player.equipped[slotType]} en ${equipmentSlotNames[slotType]}`);
                } else {
                    showMessage(`Desequipado: ${equipmentSlotNames[slotType]}`);
                }
            } else {
                const equippableItemsForSlot = player.inventory.filter(item => item.type === slotType);
                equippableItemsForSlot.unshift(null);

                let currentIndex = -1;
                const equippedItem = player.equipped[slotType];
                if (equippedItem) {
                    currentIndex = equippableItemsForSlot.findIndex(item => item && item.name === equippedItem.name);
                }
                if (currentIndex === -1) currentIndex = 0;
                let newIndex = currentIndex + 1;
                if (newIndex >= equippableItemsForSlot.length) newIndex = 0;
                player.equipped[slotType] = equippableItemsForSlot[newIndex];
                if (player.equipped[slotType]) {
                    showMessage(`Equipado: ${player.equipped[slotType].name}`);
                } else {
                    showMessage(`Desequipado: ${equipmentSlotNames[slotType]}`);
                }
            }
            updateStats();
        }
        
        function checkLevelUp() {
            const xpNeeded = [0, 100, 300, 600, 1000, 1500, 2200, 3000, 4000, 5500]; 
            while (player.level < xpNeeded.length && player.xp >= xpNeeded[player.level]) {
                player.level++; player.skillPoints++;
                showMessage(`¡Subiste al Nivel ${player.level}!`);
                player.hp = player.maxHp; 
            }
            updateStats(); 
        }

        function gameLoop(timestamp) {
            if (!gameStarted) { 
                requestAnimationFrame(gameLoop);
                return;
            }

            if (gameOver) {
                if (keys.KeyR) { 
                    keys.KeyR = false; 
                    gameStarted = false;
                    gameOver = false; 
                    
                    difficultyScreen.style.display = 'flex';
                    lastScoreDisplayElement.innerHTML = `Última Puntuación: ${lastGameScore}<br>Enemigos Derrotados: ${lastEnemiesDefeated}`;
                    difficultyTitleElement.textContent = "Selecciona la Dificultad"; 
                    gameCanvas.style.display = 'none';
                    minimapCanvas.style.display = 'none'; 
                    return; 
                }
                drawMap(); 
                requestAnimationFrame(gameLoop);
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (player.isAttacking) {
                player.attackAnimFrame++;
                if (player.attackAnimFrame >= player.attackAnimDuration) {
                    player.isAttacking = false;
                    player.attackAnimFrame = 0;
                }
            }

            const currentTime = Date.now();

            const offsetX = Math.max(0, Math.min(player.tileX * tileSize - canvas.width / 2 + tileSize / 2, mapWidth * tileSize - canvas.width));
            const offsetY = Math.max(0, Math.min(player.tileY * tileSize - canvas.height / 2 + tileSize / 2, mapHeight * tileSize - canvas.height));

            if(player.isSlowed && currentTime > player.slowEndTime){
                player.isSlowed = false;
                updateStats(); // Recalculate speed to remove slow effect
            }
            if(player.isSpeedBoosted && currentTime > player.speedBoostEndTime){
                player.isSpeedBoosted = false;
                updateStats(); 
            }
            if(player.isInvincible && currentTime > player.invincibleEndTime){
                player.isInvincible = false;
            }
            if(player.stealthActive && currentTime > player.stealthEndTime){ 
                player.stealthActive = false;
                player.stealthStatMultiplier = 1.0; 
                updateStats(); 
            }
            if(player.luckBoostEndTime > 0 && currentTime > player.luckBoostEndTime){
                player.luckBoostEndTime = 0; 
            }

            if (player.furyActive && player.hp <= player.maxHp * 0.25 && player.atk !== player.baseAtk * 2) {
                updateStats(); 
            } else if (player.furyActive && player.hp > player.maxHp * 0.25 && player.atk === player.baseAtk * 2) {
                updateStats(); 
            }

            walkFrame = (walkFrame + 1) % 20;
            monsters.forEach(m => { if (m.hitFrame > 0) m.hitFrame--; });
            
            projectiles = projectiles.filter(proj => {
                let hitSomething = false;
                // Check for collision with walls first
                const currentTileX = Math.floor(proj.x);
                const currentTileY = Math.floor(proj.y);
                if (map[currentTileY] && map[currentTileY][currentTileX] === 0) {
                    return false; 
                }
                
                for (let i = 0; i < monsters.length; i++) {
                    const m = monsters[i];
                    // Check if projectile hits player
                    if (proj.owner === 'monster' && Math.abs(player.tileX - proj.x) < 0.5 && Math.abs(player.tileY - proj.y) < 0.5) {
                        if (player.isInvincible || (currentTime - player.lastHitTime < player.invulnerabilityTime)) { 
                            if (!player.invulnerabilityMessageShown) {
                                showMessage("¡Ataque bloqueado!"); 
                                player.invulnerabilityMessageShown = true;
                            }
                        } else {
                            const blockChance = 0.05; 
                            const didBlock = Math.random() < blockChance;

                            if (didBlock) {
                                showMessage("¡Ataque Bloqueado!");
                            } else {
                                const isCritical = proj.isCritical || (Math.random() < 0.1); 
                                const damageMultiplier = isCritical ? 1.5 : 1;
                                const rawDamage = Math.floor(proj.damage * damageMultiplier);
                                const defenseReduction = Math.min(0.75, player.def * 0.03); 
                                let damageToPlayer = Math.max(1, Math.floor(rawDamage * (1 - defenseReduction)));
                                
                                if (player.hasMiniShield && player.miniShieldHP > 0) {
                                    const absorbedDamage = Math.min(damageToPlayer, player.miniShieldHP);
                                    player.miniShieldHP -= absorbedDamage;
                                    damageToPlayer -= absorbedDamage;
                                    showMessage(`Mini-escudo absorbió ${absorbedDamage} de daño.`);
                                    if (player.miniShieldHP <= 0) {
                                        player.miniShieldCooldownEnd = currentTime + 7000; 
                                        player.hasMiniShield = false;
                                        player.miniShieldHP = 0;
                                        showMessage("¡Mini-escudo roto!");
                                    }
                                }

                                if (damageToPlayer > 0) {
                                    player.hp -= damageToPlayer;
                                    player.hitFrame = 8; 
                                    player.lastHitTime = currentTime; 

                                    const playerScreenX = player.tileX * tileSize - offsetX;
                                    const playerScreenY = player.tileY * tileSize - offsetY;
                                    damageTexts.push({
                                        x: playerScreenX + tileSize/2 + (Math.random() - 0.5) * 20, 
                                        y: playerScreenY - 10 + (Math.random() - 0.5) * 10,
                                        text: isCritical ? `CRIT! ${damageToPlayer}` : `${damageToPlayer}`,
                                        color: '#ff0000', 
                                        size: isCritical ? 20 : 14,
                                        life: 30, velY: -1.2
                                    });

                                    if (player.hp <= 0) { 
                                        player.hp = 0; 
                                        lastGameScore = player.xp;
                                        lastEnemiesDefeated = player.enemiesDefeatedThisRun;
                                        finalOutcomeMessage = "Game Over";
                                        finalOutcomeMessageLine2 = "";
                                        gameOver = true; 
                                    }
                                    updateStats(); 
                                }
                            }
                        }
                        if (proj.type === 'web') {
                            player.isSlowed = true;
                            player.slowEndTime = currentTime + 3000; // Slow for 3 seconds
                            updateStats(); // Apply speed reduction immediately
                            showMessage("¡Has sido ralentizado por una telaraña!");
                        }
                        return false; // Projectile hits player, so it's removed
                    }

                    // Check if player projectile hits monster
                    if (proj.owner === 'player' && !m.isMinion && Math.abs(m.tileX - proj.x) < 0.5 && Math.abs(m.tileY - proj.y) < 0.5) {
                        const isCritical = proj.isCritical || (Math.random() < 0.2); 
                        const damageMultiplier = isCritical ? 1.5 : 1;
                        const projectileDamage = Math.floor(proj.damage * damageMultiplier);
                        m.hp -= projectileDamage; m.hitFrame = isCritical ? 10 : 5;
                        
                        const monsterScreenX = m.tileX * tileSize - offsetX;
                        const monsterScreenY = m.tileY * tileSize - offsetY;

                        damageTexts.push({
                            x: monsterScreenX + tileSize/2 * (m.width || 1), 
                            y: monsterScreenY - 10 + tileSize/2 * (m.height || 1) - tileSize/2, 
                            text: isCritical ? `¡CRÍTICO! ${Math.floor(projectileDamage)}` : `${Math.floor(projectileDamage)}`,
                            color: isCritical ? '#ff0000' : '#ffffff', size: isCritical ? 24 : 16,
                            life: 40, velY: -1.5
                        });
                        
                        if (player.soulExtractionActive) {
                            const hpRecovered = Math.floor(projectileDamage * 0.05);
                            if (hpRecovered > 0) { 
                                player.hp = Math.min(player.maxHp, player.hp + hpRecovered); 
                                damageTexts.push({ 
                                    x: player.tileX * tileSize - offsetX + tileSize/2, y: player.tileY * tileSize - offsetY - 5, 
                                    text: `+${hpRecovered} HP`,
                                    color: '#00ff00', size: 14, life: 30, velY: -1
                                });
                            }
                        }

                        if (m.hp <= 0) { 
                            let xpGained = m.xp;
                            if (activeSetBonusName === 'Mago' && setBonuses.Mago.xpGain_percent) {
                                xpGained = Math.floor(xpGained * (1 + setBonuses.Mago.xpGain_percent));
                            }
                            player.xp += xpGained;

                            player.enemiesDefeatedThisRun++;
                            if (isCritical) {
                                const healthRecovered = Math.floor(m.maxHp * 0.05); 
                                if (healthRecovered > 0) { 
                                    player.hp = Math.min(player.maxHp, player.hp + healthRecovered); 
                                    damageTexts.push({ 
                                        x: player.tileX * tileSize - offsetX + tileSize/2, y: player.tileY * tileSize - offsetY - 5, 
                                        text: `+${healthRecovered} HP`, // Corrected: Use healthRecovered
                                        color: '#00ff00', size: 14, life: 30, velY: -1
                                    });
                                }
                            }

                            // Rayo de Oscuridad: HP recovery on enemy defeated
                            if (proj.type === 'dark_ray' && proj.owner === 'player') { 
                                player.darkRayEnemiesDefeated++;
                                if (player.darkRayEnemiesDefeated >= 10) {
                                    const healedAmount = Math.floor(player.maxHp * 0.05); 
                                    if (healedAmount > 0) { 
                                        player.hp = Math.min(player.maxHp, player.hp + healedAmount);
                                        showMessage("¡Rayo de Oscuridad: ¡5% HP recuperado!");
                                    }
                                    player.darkRayEnemiesDefeated = 0;
                                }
                            }


                            if (m.dropsKey) player.hasKey = true;
                            
                            let monsterGoldDrop = Math.floor(Math.random() * (currentFloor + 1)); 
                            if (activeSetBonusName === 'Noble' && setBonuses.Noble.goldFind_percent) {
                                monsterGoldDrop = Math.floor(monsterGoldDrop * (1 + setBonuses.Noble.goldFind_percent));
                            }
                            player.gold += monsterGoldDrop;

                            const defeatedMonsterType = m.type;
                            monsters = monsters.filter(monster => monster !== m);
                            checkLevelUp();

                            if (defeatedMonsterType === 'final-arachnid-boss' && currentFloor === maxFloors) {
                                lastGameScore = player.xp;
                                lastEnemiesDefeated = player.enemiesDefeatedThisRun;
                                finalOutcomeMessage = "Haz Completado la Mazmorra"; 
                                finalOutcomeMessageLine2 = "Haz superado la clase E"; 
                                gameOver = true; 
                            } else if (monsters.filter(mon => !mon.isMinion).length === 0 && currentFloor < maxFloors) { 
                                stairLocation.active = true;
                                map[stairLocation.y][stairLocation.x] = stairLocation.type; 
                                showMessage("¡Todos los enemigos derrotados! Una escalera ha aparecido.");
                            }
                            }
                        hitSomething = true; 
                        if (proj.type === 'arrow' || proj.type === 'celestial_ray' || proj.type === 'dark_ray') { 
                            return false; 
                        }
                    }
                }
                if (hitSomething) return false; 
                
                const nextX = Math.floor(proj.x + proj.dx); const nextY = Math.floor(proj.y + proj.dy);
                if (nextX < 0 || nextX >= mapWidth || nextY < 0 || nextY >= mapHeight || (map[nextY] && map[nextY][nextX] === 0)) {
                    return false; 
                }
                return proj.update();
            });

            monsters = monsters.filter(m => {
                if (m.isMinion && m.spawnTime && m.duration) {
                    if (currentTime > m.spawnTime + m.duration) {
                        showMessage(`Tu súbdito sombra ha desaparecido.`);
                        return false; 
                    }
                }
                return true; 
            });

            monsters.forEach(m => {
                if (m.isFrozen && currentTime > m.frozenEndTime) {
                    m.isFrozen = false;
                }
                if (m.isWeakened && currentTime > m.weaknessEndTime) {
                    m.isWeakened = false;
                }
                if (m.isBleeding && currentTime > m.bleedingEndTime) {
                    m.isBleeding = false;
                    m.bleedingDamagePerTick = 0;
                    m.bleedingTickInterval = 0;
                    m.bleedingNextTickTime = 0;
                    m.bleedingEndTime = 0;
                } else if (m.isBleeding && currentTime >= m.bleedingNextTickTime) {
                    m.hp -= m.bleedingDamagePerTick; // Apply bleeding damage
                    m.hitFrame = 3; 
                    m.bleedingNextTickTime = currentTime + m.bleedingTickInterval;
                    
                    const monsterScreenX = m.tileX * tileSize - offsetX;
                    const monsterScreenY = m.tileY * tileSize - offsetY;
                    damageTexts.push({
                        x: monsterScreenX + tileSize/2 * (m.width || 1), 
                        y: monsterScreenY - 10 + tileSize/2 * (m.height || 1) - tileSize/2, 
                        text: `${Math.floor(m.bleedingDamagePerTick)}`,
                        color: '#FF4500', 
                        size: 12, life: 25, velY: -0.8
                    });

                    if (m.hp <= 0) {
                        let xpGained = m.xp;
                        if (activeSetBonusName === 'Mago' && setBonuses.Mago.xpGain_percent) {
                            xpGained = Math.floor(xpGained * (1 + setBonuses.Mago.xpGain_percent));
                        }
                        player.xp += xpGained;

                        player.enemiesDefeatedThisRun++;
                        if (m.dropsKey) player.hasKey = true;
                        
                        let monsterGoldDrop = Math.floor(Math.random() * (currentFloor + 1)); 
                        if (activeSetBonusName === 'Noble' && setBonuses.Noble.goldFind_percent) {
                            monsterGoldDrop = Math.floor(monsterGoldDrop * (1 + setBonuses.Noble.goldFind_percent));
                        }
                        player.gold += monsterGoldDrop;

                        
                        const defeatedMonsterType = m.type;
                        monsters = monsters.filter(monster => monster !== m);
                        checkLevelUp();

                        if (defeatedMonsterType === 'final-arachnid-boss' && currentFloor === maxFloors) {
                            lastGameScore = player.xp;
                            lastEnemiesDefeated = player.enemiesDefeatedThisRun;
                            finalOutcomeMessage = "Haz Completado la Mazmorra"; 
                            finalOutcomeMessageLine2 = "Haz superado la clase E"; 
                            gameOver = true; 
                        } else if (monsters.filter(mon => !mon.isMinion).length === 0 && currentFloor < maxFloors) { 
                            stairLocation.active = true;
                            map[stairLocation.y][stairLocation.x] = stairLocation.type; 
                            showMessage("¡Todos los enemigos derrotados! Una escalera ha aparecido.");
                        }
                    }
                }
                if (m.isAttackSlowed && currentTime > m.attackSlowEndTime) {
                    m.isAttackSlowed = false;
                }
            });


            if (!isInventoryOpen && !isSkillMenuOpen && !isEquipmentOpen) {
                const moveInterval = 1000 / player.spd; 
                if (timestamp - lastMoveTime > moveInterval) {
                    let moved = false;
                    if (keys.ArrowLeft || keys.KeyA) { tryMove(-1,0); moved = true; }
                    else if (keys.ArrowRight || keys.KeyD) { tryMove(1,0); moved = true; }
                    else if (keys.ArrowUp || keys.KeyW) { tryMove(0,-1); moved = true; }
                    else if (keys.ArrowDown || keys.KeyS) { tryMove(0,1); moved = true; }
                    if(moved) lastMoveTime = timestamp;
                }
                if (keys.Space && timestamp - lastAttackTime > attackInterval) {
                    performAttack();
                    lastAttackTime = timestamp;
                }
            }

            if (!isInventoryOpen && !isSkillMenuOpen && !isEquipmentOpen) {
                const currentTimeForAI = timestamp; 
                let totalDamageToPlayerThisFrame = 0;
                const monstersThatHitPlayer = [];

                // Mini-shield activation/deactivation for Escudo Colosal
                if (player.equipped.weapon && player.equipped.weapon.name === 'Escudo Colosal') {
                    if (currentTime >= player.miniShieldCooldownEnd) { 
                        let nearbyEnemies = 0;
                        monsters.filter(m => !m.isMinion).forEach(m => {
                            const dist = Math.max(Math.abs(player.tileX - m.tileX), Math.abs(player.tileY - m.tileY));
                            if (dist <= 1) { 
                                nearbyEnemies++;
                            }
                        });

                        if (nearbyEnemies >= 3 && !player.hasMiniShield) {
                            player.hasMiniShield = true;
                            player.miniShieldMaxHP = Math.floor(player.maxHp * 0.15); 
                            player.miniShieldHP = player.miniShieldMaxHP;
                            showMessage("¡Escudo Colosal: Mini-escudo activado!");
                        } else if (nearbyEnemies < 3 && player.hasMiniShield) {
                            player.hasMiniShield = false;
                            player.miniShieldHP = 0;
                            showMessage("Escudo Colosal: Mini-escudo desactivado.");
                        }
                    } else if (player.hasMiniShield && player.miniShieldHP <= 0) { 
                        player.miniShieldCooldownEnd = currentTime + 7000; 
                        player.hasMiniShield = false; 
                        player.miniShieldHP = 0;
                        showMessage("¡Mini-escudo roto!");
                    }
                } else { 
                    player.hasMiniShield = false;
                    player.miniShieldHP = 0;
                }

                monsters.forEach(m => { 
                    let currentMonsterAttackInterval = monsterAttackInterval;
                    if (m.isAttackSlowed && currentTimeForAI < m.attackSlowEndTime) {
                        currentMonsterAttackInterval *= 2; 
                    }

                    if (m.isFrozen && currentTimeForAI < m.frozenEndTime) {
                        m.lastMoveTime = currentTimeForAI; 
                        return; 
                    }
                    if (!m.lastMoveTime) m.lastMoveTime = 0; 

                    // --- Final Boss (Arachnid) Abilities ---
                    if (m.type === 'final-arachnid-boss') {
                        const distanceToPlayer = Math.max(Math.abs(player.tileX - m.tileX), Math.abs(player.tileY - m.tileY));
                        
                        // Summon Spiderlings
                        if (currentTimeForAI - (m.abilityCooldowns.summon || 0) > 15000 && distanceToPlayer <= 5) { 
                            const numSpiderlings = 4; 
                            for (let i = 0; i < numSpiderlings; i++) {
                                let spawnX = m.tileX + Math.floor(Math.random() * 3) - 1;
                                let spawnY = m.tileY + Math.floor(Math.random() * 3) - 1;
                                if (spawnX >= 0 && spawnX < mapWidth && spawnY >= 0 && spawnY < mapHeight &&
                                    (map[spawnY][spawnX] === 1 || map[spawnY][spawnX] === 2) && // Allow spawn on chests
                                    !monsters.some(otherM => otherM.tileX === spawnX && otherM.tileY === spawnY) &&
                                    !(spawnX === player.tileX && spawnY === player.tileY)) {
                                    monsters.push({ type: 'spiderling', hp: 15, maxHp: 15, atk: 5, spd: 3.0, tileX: spawnX, tileY: spawnY, xp: 10, lastMoveTime: 0, hitFrame: 0, lastAttackTime: 0, isMinion: false });
                                    showMessage("¡La Araña Jefe ha invocado mini-arañas!");
                                }
                            }
                            m.abilityCooldowns.summon = currentTimeForAI;
                        }

                        if (currentTimeForAI - (m.abilityCooldowns.webShot || 0) > 10000 && distanceToPlayer > 1) { 
                            const dx = player.tileX - m.tileX;
                            const dy = player.tileY - m.tileY;
                            projectiles.push(new Projectile(m.tileX, m.tileY, dx, dy, 'web', 'monster', m.atk * 0.5, false, 5)); 
                            showMessage("¡La Araña Jefe lanza una telaraña!");
                            m.abilityCooldowns.webShot = currentTimeForAI;
                        }
                    }

                    // --- AI Target Determination ---
                    let targetEntityForAttack = null;
                    let targetX_move, targetY_move; 

                    if (m.isMinion) { 
                        let nearestEnemy = null;
                        let minDistToEnemy = Infinity;
                        monsters.filter(enemy => !enemy.isMinion).forEach(enemy => {
                            const dist = Math.abs(m.tileX - enemy.tileX) + Math.abs(m.tileY - enemy.tileY);
                            if (dist < minDistToEnemy) {
                                minDistToEnemy = dist;
                                nearestEnemy = enemy;
                            }
                        });
                        targetEntityForAttack = nearestEnemy;
                        targetX_move = nearestEnemy ? nearestEnemy.tileX : player.tileX; 
                        targetY_move = nearestEnemy ? nearestEnemy.tileY : player.tileY;
                    } else { 
                        const playerIsCurrentlyStealthed = player.stealthActive && currentTime < player.stealthEndTime; 
                        let potentialTargets = [];

                        if (!playerIsCurrentlyStealthed) {
                            potentialTargets.push({ entity: player, isPlayer: true });
                        }

                        monsters.filter(ally => ally.isMinion).forEach(ally => {
                            potentialTargets.push({ entity: ally, isPlayer: false });
                        });

                        if (potentialTargets.length > 0) {
                            let nearestTarget = null;
                            let minDist = Infinity;

                            for (const targetObj of potentialTargets) {
                                const target = targetObj.entity;
                                const dist = Math.abs(m.tileX - target.tileX) + Math.abs(m.tileY - target.tileY);
                                if (dist < minDist) {
                                    minDist = dist;
                                    nearestTarget = target;
                                }
                            }
                            targetEntityForAttack = nearestTarget;
                            targetX_move = nearestTarget ? nearestTarget.tileX : m.tileX; 
                            targetY_move = nearestTarget ? nearestTarget.tileY : m.tileY; 
                        } else {
                            targetEntityForAttack = null;
                            targetX_move = m.tileX;
                            targetY_move = m.tileY;
                        }
                    }

                    // --- Attack Logic ---
                    let isAdjacentToTarget = false;
                    if (targetEntityForAttack) {
                        if (!(m.width > 1 || m.height > 1) && !(targetEntityForAttack.width > 1 || targetEntityForAttack.height > 1)) {
                            if (Math.abs(m.tileX - targetEntityForAttack.tileX) <= 1 &&
                                Math.abs(m.tileY - targetEntityForAttack.tileY) <= 1 &&
                                !(m.tileX === targetEntityForAttack.tileX && m.tileY === targetEntityForAttack.tileY)) {
                                isAdjacentToTarget = true;
                            }
                        } else { 
                            for (let my = m.tileY; my < m.tileY + (m.height || 1); my++) {
                                for (let mx = m.tileX; mx < m.tileX + (m.width || 1); mx++) {
                                    if (targetEntityForAttack.width && targetEntityForAttack.height) { 
                                        for (let ty = targetEntityForAttack.tileY; ty < targetEntityForAttack.tileY + targetEntityForAttack.height; ty++) {
                                            for (let tx = targetEntityForAttack.tileX; tx < targetEntityForAttack.tileX + targetEntityForAttack.width; tx++) {
                                                if ((Math.abs(tx - mx) <= 1 && Math.abs(ty - my) <= 1) && !(tx === mx && ty === my)) {
                                                    isAdjacentToTarget = true;
                                                    break;
                                                }
                                            }
                                            if (isAdjacentToTarget) break;
                                        }
                                    } else { 
                                        if ((Math.abs(targetEntityForAttack.tileX - mx) <= 1 && Math.abs(targetEntityForAttack.tileY - my) <= 1) && !(targetEntityForAttack.tileX === mx && targetEntityForAttack.tileY === my)) {
                                            isAdjacentToTarget = true;
                                            break;
                                        }
                                    }
                                }
                                if (isAdjacentToTarget) break;
                            }
                            if (targetEntityForAttack === player && m.type === 'final-arachnid-boss' &&
                                player.tileX >= m.tileX && player.tileX < m.tileX + m.width &&
                                player.tileY >= m.tileY && player.tileY < m.tileY + m.height) {
                                isAdjacentToTarget = true;
                            }
                        }
                    }

                    if (isAdjacentToTarget && currentTimeForAI - m.lastAttackTime > currentMonsterAttackInterval) {
                        if (m.isMinion) { 
                            if (targetEntityForAttack) { 
                                const damage = m.atk;
                                targetEntityForAttack.hp -= damage;
                                targetEntityForAttack.hitFrame = 5;

                                const targetScreenX = targetEntityForAttack.tileX * tileSize - offsetX;
                                const targetScreenY = targetEntityForAttack.tileY * tileSize - offsetY;
                                damageTexts.push({
                                    x: targetScreenX + tileSize/2 * (targetEntityForAttack.width || 1), 
                                    y: targetScreenY - 10 + tileSize/2 * (targetEntityForAttack.height || 1) - tileSize/2, 
                                    text: `${Math.floor(damage)}`,
                                    color: '#00FFFF', 
                                    size: 14, life: 30, velY: -1.2
                                });

                                if (targetEntityForAttack.hp <= 0) {
                                    let xpGained = targetEntityForAttack.xp;
                                    if (activeSetBonusName === 'Mago' && setBonuses.Mago.xpGain_percent) {
                                        xpGained = Math.floor(xpGained * (1 + setBonuses.Mago.xpGain_percent));
                                    }
                                    player.xp += xpGained;

                                    player.enemiesDefeatedThisRun++;
                                    if (targetEntityForAttack.dropsKey) player.hasKey = true;
                                    
                                    let monsterGoldDrop = Math.floor(Math.random() * (currentFloor + 1)); 
                                    if (activeSetBonusName === 'Noble' && setBonuses.Noble.goldFind_percent) {
                                        monsterGoldDrop = Math.floor(monsterGoldDrop * (1 + setBonuses.Noble.goldFind_percent));
                                    }
                                    player.gold += monsterGoldDrop;

                                    
                                    const defeatedMonsterType = targetEntityForAttack.type;
                                    monsters = monsters.filter(monster => monster !== targetEntityForAttack);
                                    checkLevelUp();

                                    if (defeatedMonsterType === 'final-arachnid-boss' && currentFloor === maxFloors) {
                                        lastGameScore = player.xp;
                                        lastEnemiesDefeated = player.enemiesDefeatedThisRun;
                                        finalOutcomeMessage = "Haz Completado la Mazmorra"; 
                                        finalOutcomeMessageLine2 = "Haz superado la clase E"; 
                                        gameOver = true; 
                                    } else if (monsters.filter(mon => !mon.isMinion).length === 0 && currentFloor < maxFloors) { 
                                        stairLocation.active = true;
                                        map[stairLocation.y][stairLocation.x] = stairLocation.type; 
                                        showMessage("¡Todos los enemigos derrotados! Una escalera ha aparecido.");
                                    }
                                }
                            }
                        } else { 
                            if (targetEntityForAttack === player) {
                                if (player.isInvincible || (currentTime - player.lastHitTime < player.invulnerabilityTime)) { 
                                    if (!player.invulnerabilityMessageShown) {
                                        showMessage("¡Ataque bloqueado!"); 
                                        player.invulnerabilityMessageShown = true;
                                    }
                                } else { 
                                    const blockChance = 0.05; 
                                    const didBlock = Math.random() < blockChance;

                                    if (didBlock) {
                                        showMessage("¡Ataque Bloqueado!");
                                    } else {
                                        const isCritical = Math.random() < 0.1; 
                                        const damageMultiplier = isCritical ? 1.5 : 1;
                                        const rawDamage = Math.floor(m.atk * damageMultiplier);
                                        const defenseReduction = Math.min(0.75, player.def * 0.03); 
                                        let damageToPlayer = Math.max(1, Math.floor(rawDamage * (1 - defenseReduction)));
                                        
                                        if (player.hasMiniShield && player.miniShieldHP > 0) {
                                            const absorbedDamage = Math.min(damageToPlayer, player.miniShieldHP);
                                            player.miniShieldHP -= absorbedDamage;
                                            damageToPlayer -= absorbedDamage;
                                            showMessage(`Mini-escudo absorbió ${absorbedDamage} de daño.`);
                                            if (player.miniShieldHP <= 0) {
                                                player.miniShieldCooldownEnd = currentTime + 7000; 
                                                player.hasMiniShield = false;
                                                player.miniShieldHP = 0;
                                                showMessage("¡Mini-escudo roto!");
                                            }
                                        }

                                        if (damageToPlayer > 0) {
                                            totalDamageToPlayerThisFrame += damageToPlayer;
                                            monstersThatHitPlayer.push({ monster: m, damage: damageToPlayer, isCritical: isCritical });
                                        }
                                    }
                                }
                            } else if (targetEntityForAttack && targetEntityForAttack.isMinion) { 
                                if (targetEntityForAttack) { 
                                    const damage = m.atk;
                                    targetEntityForAttack.hp -= damage;
                                    targetEntityForAttack.hitFrame = 5;

                                    const targetScreenX = targetEntityForAttack.tileX * tileSize - offsetX;
                                    const targetScreenY = targetEntityForAttack.tileY * tileSize - offsetY;
                                    damageTexts.push({
                                        x: targetScreenX + tileSize/2 * (targetEntityForAttack.width || 1),
                                        y: targetScreenY - 10 + tileSize/2 * (targetEntityForAttack.height || 1) - tileSize/2,
                                        text: `${Math.floor(damage)}`,
                                        color: '#FF0000', 
                                        size: 14, life: 30, velY: -1.2
                                    });

                                    if (targetEntityForAttack.hp <= 0) {
                                        showMessage(`Tu súbdito sombra ha sido derrotado.`);
                                        monsters = monsters.filter(monster => monster !== targetEntityForAttack);
                                    }
                                }
                            }
                        }
                        m.lastAttackTime = currentTimeForAI; 
                        m.hitFrame = 5; 
                    } else { 
                        if (currentTimeForAI - m.lastMoveTime > 1000 / m.spd) { 
                            const playerIsCurrentlyStealthed = player.stealthActive && currentTime < player.stealthEndTime; 
                            if (!m.isMinion && playerIsCurrentlyStealthed && !targetEntityForAttack) { 
                                m.lastMoveTime = currentTimeForAI;
                                return;
                            }

                            if (targetEntityForAttack) { 
                                const dxTarget = targetX_move - m.tileX; 
                                const dyTarget = targetY_move - m.tileY;

                                let primaryMoveX = 0, primaryMoveY = 0;
                                if (Math.abs(dxTarget) > Math.abs(dyTarget)) {
                                    primaryMoveX = dxTarget > 0 ? 1 : -1;
                                } else if (Math.abs(dyTarget) > 0) { 
                                    primaryMoveY = dyTarget > 0 ? 1 : -1;
                                }

                                let potentialMoves = [
                                    {x: m.tileX + primaryMoveX, y: m.tileY + primaryMoveY}, 
                                ];
                                if (primaryMoveX !== 0) { 
                                    potentialMoves.push({x: m.tileX + primaryMoveX, y: m.tileY - 1});
                                    potentialMoves.push({x: m.tileX + primaryMoveX, y: m.tileY + 1});
                                    if (dyTarget !== 0) potentialMoves.push({x: m.tileX, y: m.tileY + (dyTarget > 0 ? 1 : -1)});
                                } else { 
                                    potentialMoves.push({x: m.tileX - 1, y: m.tileY + primaryMoveY});
                                    potentialMoves.push({x: m.tileX + 1, y: m.tileY + primaryMoveY});
                                    if (dxTarget !== 0) potentialMoves.push({x: m.tileX + (dxTarget > 0 ? 1 : -1), y: m.tileY});
                                }
                                potentialMoves.sort(() => Math.random() - 0.5);

                                let movedThisTurnForMonster = false;
                                for (const move of potentialMoves) {
                                    const isTargetPlayer = (move.x === player.tileX && move.y === player.tileY);
                                    const isTargetOtherMonster = monsters.some(otherM => otherM !== m && otherM.tileX === move.x && otherM.tileY === move.y);
                                    
                                    // Allow monsters to move onto chests (map type 2)
                                    if (move.x >= 0 && move.x < mapWidth && move.y >= 0 && move.y < mapHeight &&
                                        (map[move.y][move.x] === 1 || map[move.y][move.x] === 2) && // Allow movement onto floor (1) or chest (2)
                                        !isTargetPlayer && !isTargetOtherMonster) {
                                        
                                        m.tileX = move.x;
                                        m.tileY = move.y;
                                        movedThisTurnForMonster = true;
                                        break;
                                    }
                                }
                            if(movedThisTurnForMonster) m.lastMoveTime = currentTimeForAI;
                            } else { // If no target, monster doesn't move
                                m.lastMoveTime = currentTimeForAI;
                            }
                        }
                    }
                });

                if (totalDamageToPlayerThisFrame > 0) {
                    if (player.isInvincible || (currentTime - player.lastHitTime < player.invulnerabilityTime)) { 
                        if (!player.invulnerabilityMessageShown) {
                            showMessage("¡Ataque bloqueado!"); 
                            player.invulnerabilityMessageShown = true;
                        }
                    } else { 
                        player.hp -= totalDamageToPlayerThisFrame; 
                        player.hitFrame = 8; 
                        player.lastHitTime = currentTime; 

                        const playerScreenX = player.tileX * tileSize - offsetX;
                        const playerScreenY = player.tileY * tileSize - offsetY;

                        monstersThatHitPlayer.forEach(hit => {
                            damageTexts.push({
                                x: playerScreenX + tileSize/2 + (Math.random() - 0.5) * 20, 
                                y: playerScreenY - 10 + (Math.random() - 0.5) * 10,
                                text: hit.isCritical ? `CRIT! ${hit.damage}` : `${hit.damage}`,
                                color: '#ff0000', 
                                size: hit.isCritical ? 20 : 14,
                                life: 30, velY: -1.2
                            });
                        });

                        if (player.hp <= 0) { 
                            player.hp = 0; 
                            lastGameScore = player.xp;
                            lastEnemiesDefeated = player.enemiesDefeatedThisRun;
                            finalOutcomeMessage = "Game Over";
                            finalOutcomeMessageLine2 = "";
                            gameOver = true; 
                        }
                        updateStats(); 
                    }
                } else {
                    player.invulnerabilityMessageShown = false; 
                }
            }
            drawMap();
            requestAnimationFrame(gameLoop);
        }

        loadPlayerDataFromLocalStorage(); 
        difficultyScreen.style.display = 'flex'; 
        gameCanvas.style.display = 'none';
        minimapCanvas.style.display = 'none'; 
        equipmentMenu.style.display = 'none'; 
    </script>
</body>
</html>